"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const i=require("./holster-storage-C9HD0S4m.cjs"),g=require("crypto");class f{constructor(t){if(this.value=t,t.length!==16)throw new Error("Wire label must be 16 bytes (128 bits)")}static random(){return new f(g.randomBytes(16))}equals(t){if(this.value.length!==t.value.length)return!1;for(let e=0;e<this.value.length;e++)if(this.value[e]!==t.value[e])return!1;return!0}}class v{wireLabels=new Map;nextWireId=0;createWire(){const t=this.nextWireId++,e=f.random(),r=f.random();return this.wireLabels.set(t,[e,r]),t}getWireLabels(t){const e=this.wireLabels.get(t);if(!e)throw new Error(`Wire ${t} not found`);return e}garbleGate(t){const e=[];if(t.type==="XOR")return{gateId:t.output,encryptedTable:[]};const[r,s]=this.getWireLabels(t.inputs[0]),[n,c]=t.inputs[1]!==void 0?this.getWireLabels(t.inputs[1]):[r,s],[o,l]=this.getWireLabels(t.output),h=this.getTruthTable(t.type);for(let u=0;u<=1;u++)for(let m=0;m<=1;m++){if(t.type==="NOT"&&m>0)continue;const d=u===0?r:s,p=m===0?n:c,R=h[u][m]===0?o:l,C=this.encrypt(R,d,p);e.push(C)}return this.permuteTable(e),{gateId:t.output,encryptedTable:e}}encrypt(t,e,r){const s=new Uint8Array(32);s.set(e.value,0),s.set(r.value,16);const n=i.sha256(s).slice(0,16),c=new Uint8Array(16);return g.createCipheriv("aes-128-ctr",Buffer.from(n),Buffer.from(c)).update(Buffer.from(t.value))}permuteTable(t){for(let e=t.length-1;e>0;e--){const r=Math.floor(Math.random()*(e+1));[t[e],t[r]]=[t[r],t[e]]}}getTruthTable(t){switch(t){case"AND":return[[0,0],[0,1]];case"OR":return[[0,1],[1,1]];case"XOR":return[[0,1],[1,0]];case"NOT":return[[1],[0]];default:throw new Error(`Unknown gate type: ${t}`)}}}class ${evaluateGate(t,e,r){if(t.encryptedTable.length===0)return this.evaluateXOR(e,r);for(const s of t.encryptedTable)try{return this.decrypt(s,e,r)}catch{continue}throw new Error("Failed to evaluate garbled gate")}decrypt(t,e,r){const s=new Uint8Array(32);s.set(e.value,0),s.set(r.value,16);const n=i.sha256(s).slice(0,16),c=new Uint8Array(16),l=g.createDecipheriv("aes-128-ctr",Buffer.from(n),Buffer.from(c)).update(Buffer.from(t));return new f(l)}evaluateXOR(t,e){const r=new Uint8Array(16);for(let s=0;s<16;s++)r[s]=t.value[s]^e.value[s];return new f(r)}}class E{bitWidth;garbler;constructor(t=32){this.bitWidth=t,this.garbler=new v}buildCircuit(t,e){const r=this.numberToBits(t),s=this.numberToBits(e),n=r.map(()=>this.garbler.createWire()),c=s.map(()=>this.garbler.createWire()),o=this.buildComparator(n,c),l=this.buildMultiplexer(o,n,c),h=[];return{result:Math.min(t,e),garbledCircuit:{gates:h,wireLabels:new Map,outputWires:l}}}numberToBits(t){const e=[];for(let r=0;r<this.bitWidth;r++)e.push((t>>r&1)===1);return e}buildComparator(t,e){return this.garbler.createWire()}buildMultiplexer(t,e,r){return e.map(()=>this.garbler.createWire())}}async function I(a,t){const e=Math.floor(a*1e3),r=Math.floor(t*1e3),s=new E(32),{result:n}=s.buildCircuit(e,r);return n/1e3}function b(a,t){try{if(!a||!a._)return null;const e=a._[">"];if(!e||typeof e!="object")return null;const r=e[t];return typeof r=="number"&&r>0?r:null}catch(e){return console.error("[HOLSTER-TIMESTAMP] Error extracting timestamp:",e),null}}function T(a,t){return a===null&&t===null?0:a===null?-1:t===null?1:a-t}function w(a,t,e){const r=b(a,t);return T(r,e)>0}function O(a){try{if(!a||!a._||!a._[">"])return null;const t=a._[">"];let e=null;for(const r of Object.keys(t)){const s=t[r];typeof s=="number"&&(e===null||s>e)&&(e=s)}return e}catch(t){return console.error("[HOLSTER-TIMESTAMP] Error finding most recent timestamp:",t),null}}function y(a){if(a===null)return!1;const t=new Date("1970-01-02T00:00:00.000Z").getTime();return a>t}function P(a){if(a===null)return"Unknown";try{return new Date(a).toISOString()}catch{return"Invalid"}}function W(a){try{return a?._?.["#"]||null}catch{return null}}function A(a,t){if(t===null)return a;const e=y(t);return a?!e&&a.reliable?a:t>a.value?{value:t,reliable:e,updatedAt:Date.now()}:a:{value:t,reliable:e,updatedAt:Date.now()}}class M{constructor(t,e,r,s){this.holsterPath=t,this.streamType=e,this.onData=r,this.onError=s,this.streamId=`${e}_${Math.random().toString(36).substr(2,9)}`}reader=null;stream=null;isActive=!1;holsterRef;streamId;async start(){if(this.isActive){console.warn(`[STREAM] ${this.streamType} stream already active`);return}try{this.isActive=!0,console.log(`[STREAM] Starting ${this.streamType} stream ${this.streamId}`),this.stream=new ReadableStream({start:t=>{try{if(this.holsterRef=this.holsterPath(),!this.holsterRef){console.warn(`[STREAM] No Holster reference for ${this.streamType} stream ${this.streamId}`);return}this.holsterRef.on(e=>{this.isActive&&e!=null&&t.enqueue(e)}),console.log(`[STREAM] ${this.streamType} stream ${this.streamId} started successfully`)}catch(e){console.error(`[STREAM] Error starting ${this.streamType} stream:`,e),t.error(e),this.onError?.(e)}},cancel:()=>{console.log(`[STREAM] Cancelling ${this.streamType} stream ${this.streamId}`),this.cleanup()}}),this.reader=this.stream.getReader(),this.processStream()}catch(t){console.error(`[STREAM] Failed to start ${this.streamType} stream:`,t),this.cleanup(),this.onError?.(t)}}async processStream(){if(this.reader)try{for(;this.isActive;){const{value:t,done:e}=await this.reader.read();if(e){console.log(`[STREAM] ${this.streamType} stream ${this.streamId} completed`);break}t&&this.isActive&&this.onData(t)}}catch(t){this.isActive&&(console.error(`[STREAM] Error in ${this.streamType} stream:`,t),this.onError?.(t))}finally{this.isActive||this.cleanup()}}stop(){this.isActive&&(console.log(`[STREAM] Stopping ${this.streamType} stream ${this.streamId}`),this.isActive=!1,this.cleanup())}cleanup(){this.isActive=!1;try{this.reader&&(this.reader.cancel(),this.reader=null),this.holsterRef&&typeof this.holsterRef.off=="function"&&(this.holsterRef.off(),this.holsterRef=null),this.stream=null,console.log(`[STREAM] Cleaned up ${this.streamType} stream ${this.streamId}`)}catch(t){console.error(`[STREAM] Error during cleanup of ${this.streamType} stream:`,t)}}get active(){return this.isActive}}class _{activeStreams=new Map;subscriptionType;lastContributorsList=[];isUpdating=!1;constructor(t){this.subscriptionType=t}async createStream(t,e,r,s,n){const c=`${t}_${r}`,o=this.activeStreams.get(c);if(o&&o.active)return;o&&(o.stop(),this.activeStreams.delete(c));const l=new M(e,`${this.subscriptionType}_${r}`,s,n);this.activeStreams.set(c,l);try{await l.start()}catch(h){throw this.activeStreams.delete(c),h}}stopStream(t,e){const r=`${t}_${e}`,s=this.activeStreams.get(r);s&&(s.stop(),this.activeStreams.delete(r))}stopContributorStreams(t){const e=[];for(const[r,s]of this.activeStreams.entries())r.startsWith(`${t}_`)&&(s.stop(),e.push(r));e.forEach(r=>this.activeStreams.delete(r))}stopAllStreams(){console.log(`[STREAM-MANAGER] Stopping all ${this.subscriptionType} streams`);for(const[t,e]of this.activeStreams.entries())e.stop();this.activeStreams.clear(),this.lastContributorsList=[]}arraysEqual(t,e){if(t.length!==e.length)return!1;const r=[...t].sort(),s=[...e].sort();return r.every((n,c)=>n===s[c])}async updateSubscriptions(t,e){if(!this.isUpdating&&!this.arraysEqual(t,this.lastContributorsList)){this.isUpdating=!0;try{if(!t.length){this.stopAllStreams();return}console.log(`[STREAM-MANAGER] Updating ${this.subscriptionType} subscriptions for ${t.length} contributors`);const r=new Set;for(const o of this.activeStreams.keys()){const l=o.split("_")[0];r.add(l)}const s=new Set(t),n=t.filter(o=>!r.has(o)),c=Array.from(r).filter(o=>!s.has(o));for(const o of c)this.stopContributorStreams(o);for(const o of n)try{await e(o)}catch(l){console.error(`[STREAM-MANAGER] Failed to create streams for contributor ${o}:`,l)}this.lastContributorsList=[...t],console.log(`[STREAM-MANAGER] ${this.subscriptionType} streams: +${n.length} -${c.length} (total: ${this.activeStreams.size})`)}finally{this.isUpdating=!1}}}get streamCount(){return this.activeStreams.size}get activeStreamKeys(){return Array.from(this.activeStreams.keys())}}function D(a){let t=null;return e=>{const{dataType:r,validator:s,getCurrentData:n,updateStore:c,onUpdate:o,enableTimestampComparison:l,timestampField:h}=a;if(!e){console.log(`[PROCESSOR] No ${r} data found`);return}try{let u=e;if(s&&(u=s(e),!u)){console.error(`[PROCESSOR] Failed to validate ${r} data`);return}const m=n();if(l)try{const p=b(e,h||"_");if(p!==null){const S=A(t,p);if(S&&S!==t){if(T(p,t?.value||null)<=0&&y(p)){console.log(`[PROCESSOR] Incoming ${r} is older/same, ignoring update`);return}y(p)&&(console.log(`[PROCESSOR] Incoming ${r} is newer, accepting update`),t=S)}}}catch(d){console.warn(`[PROCESSOR] Error extracting timestamps for ${r}:`,d)}if(m&&JSON.stringify(m)===JSON.stringify(u))return;console.log(`[PROCESSOR] ${r} data changed, updating store`),u&&typeof u=="object"&&(c(u),o?.())}catch(u){console.error(`[PROCESSOR] Error processing ${r}:`,u)}}}exports.AllocationError=i.AllocationError;exports.AllocationSchema=i.AllocationSchema;exports.CapacityIDSchema=i.CapacityIDSchema;exports.CapacitySchema=i.CapacitySchema;exports.CommitmentHelper=i.CommitmentHelper;exports.CommitmentSchema=i.CommitmentSchema;exports.CryptographicError=i.CryptographicError;exports.DIDSchema=i.DIDSchema;exports.DesireSchema=i.DesireSchema;exports.HolsterStorage=i.HolsterStorage;exports.MPCProtocol=i.MPCProtocol;exports.MetricsCollector=i.MetricsCollector;exports.MutualRecognitionSchema=i.MutualRecognitionSchema;exports.ParticipantSchema=i.ParticipantSchema;exports.PercentageSchema=i.PercentageSchema;exports.RDXConfigSchema=i.RDXConfigSchema;exports.RDXException=i.RDXException;exports.RecognitionValueSchema=i.RecognitionValueSchema;exports.Schemas=i.Schemas;exports.SecretSharing=i.SecretSharing;exports.SecureMemory=i.SecureMemory;exports.ShareSchema=i.ShareSchema;exports.TEESimulator=i.TEESimulator;exports.ValidationError=i.ValidationError;exports.commit=i.commit;exports.createAllocation=i.createAllocation;exports.createCapacity=i.createCapacity;exports.createCommitment=i.commit;exports.createDesire=i.createDesire;exports.createMutualRecognition=i.createMutualRecognition;exports.createParticipant=i.createParticipant;exports.createRDXConfig=i.createRDXConfig;exports.createRecognitionValue=i.createRecognitionValue;exports.getValidationErrors=i.getValidationErrors;exports.parse=i.parse;exports.validate=i.validate;exports.verify=i.verifyCommitment;exports.verifyCommitment=i.verifyCommitment;exports.Evaluator=$;exports.Garbler=v;exports.HolsterSubscriptionStream=M;exports.SecureMinCircuit=E;exports.StreamSubscriptionManager=_;exports.WireLabel=f;exports.compareTimestamps=T;exports.createDataProcessor=D;exports.formatTimestamp=P;exports.getHolsterTimestamp=b;exports.getMostRecentTimestamp=O;exports.getNodeId=W;exports.isDataNewer=w;exports.isReliableTimestamp=y;exports.secureMinimumGarbled=I;exports.updateTimestampMetadata=A;
//# sourceMappingURL=index.cjs.map
