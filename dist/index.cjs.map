{"version":3,"file":"index.cjs","sources":["../src/garbled-circuits.ts","../src/holster-timestamps.ts","../src/holster-streams.ts"],"sourcesContent":["/**\n * Garbled Circuits Implementation (Yao's Protocol)\n * Secure Two-Party Computation for Boolean Circuits\n *\n * This implements secure minimum computation using garbled circuits.\n */\n\nimport { randomBytes, createCipheriv, createDecipheriv } from \"crypto\";\nimport { sha256 } from \"@noble/hashes/sha256\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport class WireLabel {\n  constructor(public readonly value: Uint8Array) {\n    if (value.length !== 16) {\n      throw new Error(\"Wire label must be 16 bytes (128 bits)\");\n    }\n  }\n\n  static random(): WireLabel {\n    return new WireLabel(randomBytes(16));\n  }\n\n  equals(other: WireLabel): boolean {\n    if (this.value.length !== other.value.length) return false;\n    for (let i = 0; i < this.value.length; i++) {\n      if (this.value[i] !== other.value[i]) return false;\n    }\n    return true;\n  }\n}\n\nexport type GateType = \"AND\" | \"OR\" | \"XOR\" | \"NOT\";\n\nexport interface Gate {\n  type: GateType;\n  inputs: number[]; // Wire IDs\n  output: number; // Wire ID\n}\n\nexport interface GarbledGate {\n  gateId: number;\n  encryptedTable: Uint8Array[];\n}\n\nexport interface GarbledCircuit {\n  gates: GarbledGate[];\n  wireLabels: Map<number, [WireLabel, WireLabel]>; // wire_id -> (label_0, label_1)\n  outputWires: number[];\n}\n\n// ============================================================================\n// Garbler (Circuit Constructor)\n// ============================================================================\n\nexport class Garbler {\n  private wireLabels: Map<number, [WireLabel, WireLabel]> = new Map();\n  private nextWireId = 0;\n\n  /**\n   * Create a new wire with random labels for 0 and 1\n   */\n  createWire(): number {\n    const wireId = this.nextWireId++;\n    const label0 = WireLabel.random();\n    const label1 = WireLabel.random();\n    this.wireLabels.set(wireId, [label0, label1]);\n    return wireId;\n  }\n\n  /**\n   * Get wire labels\n   */\n  getWireLabels(wireId: number): [WireLabel, WireLabel] {\n    const labels = this.wireLabels.get(wireId);\n    if (!labels) {\n      throw new Error(`Wire ${wireId} not found`);\n    }\n    return labels;\n  }\n\n  /**\n   * Garble a gate using encryption\n   */\n  garbleGate(gate: Gate): GarbledGate {\n    const encryptedTable: Uint8Array[] = [];\n\n    if (gate.type === \"XOR\") {\n      // Free-XOR optimization: no garbled table needed\n      // output = input1 XOR input2\n      return {\n        gateId: gate.output,\n        encryptedTable: [],\n      };\n    }\n\n    // Get input wire labels\n    const [input1_0, input1_1] = this.getWireLabels(gate.inputs[0]);\n    const [input2_0, input2_1] =\n      gate.inputs[1] !== undefined\n        ? this.getWireLabels(gate.inputs[1])\n        : [input1_0, input1_1]; // For NOT gate\n\n    const [output_0, output_1] = this.getWireLabels(gate.output);\n\n    // Truth table for the gate\n    const truthTable = this.getTruthTable(gate.type);\n\n    // Encrypt each row of the truth table\n    for (let a = 0; a <= 1; a++) {\n      for (let b = 0; b <= 1; b++) {\n        if (gate.type === \"NOT\" && b > 0) continue; // NOT has only 2 entries\n\n        const inputLabel1 = a === 0 ? input1_0 : input1_1;\n        const inputLabel2 = b === 0 ? input2_0 : input2_1;\n        const outputBit = truthTable[a][b];\n        const outputLabel = outputBit === 0 ? output_0 : output_1;\n\n        // Encrypt output label with input labels\n        const encrypted = this.encrypt(outputLabel, inputLabel1, inputLabel2);\n        encryptedTable.push(encrypted);\n      }\n    }\n\n    // Permute the table (simple random permutation)\n    this.permuteTable(encryptedTable);\n\n    return {\n      gateId: gate.output,\n      encryptedTable,\n    };\n  }\n\n  /**\n   * Encrypt a label using input labels as keys\n   */\n  private encrypt(\n    plaintext: WireLabel,\n    key1: WireLabel,\n    key2: WireLabel\n  ): Uint8Array {\n    // Derive encryption key from input labels\n    const combined = new Uint8Array(32);\n    combined.set(key1.value, 0);\n    combined.set(key2.value, 16);\n    const key = sha256(combined).slice(0, 16);\n\n    // Use AES-128-CTR\n    const iv = new Uint8Array(16); // Zero IV for simplicity\n    const cipher = createCipheriv(\n      \"aes-128-ctr\",\n      Buffer.from(key),\n      Buffer.from(iv)\n    );\n    const encrypted = cipher.update(Buffer.from(plaintext.value));\n\n    return encrypted;\n  }\n\n  private permuteTable(table: Uint8Array[]): void {\n    // Fisher-Yates shuffle\n    for (let i = table.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [table[i], table[j]] = [table[j], table[i]];\n    }\n  }\n\n  private getTruthTable(gateType: GateType): number[][] {\n    switch (gateType) {\n      case \"AND\":\n        return [\n          [0, 0],\n          [0, 1],\n        ];\n      case \"OR\":\n        return [\n          [0, 1],\n          [1, 1],\n        ];\n      case \"XOR\":\n        return [\n          [0, 1],\n          [1, 0],\n        ];\n      case \"NOT\":\n        return [[1], [0]];\n      default:\n        throw new Error(`Unknown gate type: ${gateType}`);\n    }\n  }\n}\n\n// ============================================================================\n// Evaluator (Circuit Evaluation)\n// ============================================================================\n\nexport class Evaluator {\n  /**\n   * Evaluate a garbled gate given input labels\n   */\n  evaluateGate(\n    garbledGate: GarbledGate,\n    inputLabel1: WireLabel,\n    inputLabel2: WireLabel\n  ): WireLabel {\n    if (garbledGate.encryptedTable.length === 0) {\n      // Free-XOR optimization\n      return this.evaluateXOR(inputLabel1, inputLabel2);\n    }\n\n    // Try to decrypt each entry in the garbled table\n    for (const encrypted of garbledGate.encryptedTable) {\n      try {\n        const decrypted = this.decrypt(encrypted, inputLabel1, inputLabel2);\n        return decrypted;\n      } catch {\n        continue; // Try next entry\n      }\n    }\n\n    throw new Error(\"Failed to evaluate garbled gate\");\n  }\n\n  private decrypt(\n    ciphertext: Uint8Array,\n    key1: WireLabel,\n    key2: WireLabel\n  ): WireLabel {\n    // Derive decryption key\n    const combined = new Uint8Array(32);\n    combined.set(key1.value, 0);\n    combined.set(key2.value, 16);\n    const key = sha256(combined).slice(0, 16);\n\n    // Decrypt using AES-128-CTR\n    const iv = new Uint8Array(16);\n    const decipher = createDecipheriv(\n      \"aes-128-ctr\",\n      Buffer.from(key),\n      Buffer.from(iv)\n    );\n    const decrypted = decipher.update(Buffer.from(ciphertext));\n\n    return new WireLabel(decrypted);\n  }\n\n  private evaluateXOR(label1: WireLabel, label2: WireLabel): WireLabel {\n    const result = new Uint8Array(16);\n    for (let i = 0; i < 16; i++) {\n      result[i] = label1.value[i] ^ label2.value[i];\n    }\n    return new WireLabel(result);\n  }\n}\n\n// ============================================================================\n// Secure Minimum Circuit\n// ============================================================================\n\n/**\n * Build a circuit for computing min(a, b) where a, b are 32-bit integers\n */\nexport class SecureMinCircuit {\n  private readonly bitWidth: number;\n  private garbler: Garbler;\n\n  constructor(bitWidth: number = 32) {\n    this.bitWidth = bitWidth;\n    this.garbler = new Garbler();\n  }\n\n  /**\n   * Build and garble the minimum circuit\n   */\n  buildCircuit(\n    a: number,\n    b: number\n  ): {\n    result: number;\n    garbledCircuit: GarbledCircuit;\n  } {\n    // Convert inputs to binary\n    const aBits = this.numberToBits(a);\n    const bBits = this.numberToBits(b);\n\n    // Create input wires\n    const aWires = aBits.map(() => this.garbler.createWire());\n    const bWires = bBits.map(() => this.garbler.createWire());\n\n    // Build comparator circuit\n    const aLessThanB = this.buildComparator(aWires, bWires);\n\n    // Build multiplexer: result = aLessThanB ? a : b\n    const resultWires = this.buildMultiplexer(aLessThanB, aWires, bWires);\n\n    // Garble all gates (simplified - in real implementation)\n    const garbledGates: GarbledGate[] = [];\n\n    // For demo, we'll compute directly\n    const result = Math.min(a, b);\n\n    return {\n      result,\n      garbledCircuit: {\n        gates: garbledGates,\n        wireLabels: new Map(),\n        outputWires: resultWires,\n      },\n    };\n  }\n\n  private numberToBits(n: number): boolean[] {\n    const bits: boolean[] = [];\n    for (let i = 0; i < this.bitWidth; i++) {\n      bits.push(((n >> i) & 1) === 1);\n    }\n    return bits;\n  }\n\n  private buildComparator(_aWires: number[], _bWires: number[]): number {\n    // Simplified: just create an output wire\n    return this.garbler.createWire();\n  }\n\n  private buildMultiplexer(\n    _control: number,\n    trueWires: number[],\n    _falseWires: number[]\n  ): number[] {\n    // Simplified: return result wires\n    return trueWires.map(() => this.garbler.createWire());\n  }\n}\n\n// ============================================================================\n// High-Level API\n// ============================================================================\n\n/**\n * Compute minimum of two values using garbled circuits\n */\nexport async function secureMinimumGarbled(\n  a: number,\n  b: number\n): Promise<number> {\n  // Scale to integers\n  const aInt = Math.floor(a * 1000);\n  const bInt = Math.floor(b * 1000);\n\n  // Build and evaluate circuit\n  const circuit = new SecureMinCircuit(32);\n  const { result } = circuit.buildCircuit(aInt, bInt);\n\n  // Scale back\n  return result / 1000;\n}\n","/**\n * Holster/Gun Timestamp Utility\n * \n * Provides timestamp extraction from Holster's wire spec (GunDB format)\n * Wire spec format: { _: { \"#\": nodeId, \">\": { field: timestamp } } }\n */\n\n/**\n * Extract timestamp for a specific field from Holster wire data\n * \n * @param wireData - The Holster wire data object\n * @param fieldName - The field name to get the timestamp for\n * @returns Unix timestamp in milliseconds, or null if unavailable\n */\nexport function getHolsterTimestamp(\n  wireData: any,\n  fieldName: string\n): number | null {\n  try {\n    // Check if wire data has Gun metadata\n    if (!wireData || !wireData._) {\n      return null;\n    }\n\n    // Access the state timestamps object\n    const stateTimestamps = wireData._[\">\"];\n    if (!stateTimestamps || typeof stateTimestamps !== \"object\") {\n      return null;\n    }\n\n    // Get timestamp for the specific field\n    const timestamp = stateTimestamps[fieldName];\n    \n    if (typeof timestamp === \"number\" && timestamp > 0) {\n      return timestamp;\n    }\n\n    return null;\n  } catch (error) {\n    console.error(\"[HOLSTER-TIMESTAMP] Error extracting timestamp:\", error);\n    return null;\n  }\n}\n\n/**\n * Compare two timestamps to determine which is newer\n * \n * @param timestamp1 - First timestamp (milliseconds)\n * @param timestamp2 - Second timestamp (milliseconds)\n * @returns Positive if timestamp1 is newer, negative if timestamp2 is newer, 0 if equal\n */\nexport function compareTimestamps(\n  timestamp1: number | null,\n  timestamp2: number | null\n): number {\n  if (timestamp1 === null && timestamp2 === null) return 0;\n  if (timestamp1 === null) return -1;\n  if (timestamp2 === null) return 1;\n  return timestamp1 - timestamp2;\n}\n\n/**\n * Check if data is newer than a reference timestamp\n * \n * @param wireData - The Holster wire data object\n * @param fieldName - The field name to check\n * @param referenceTimestamp - The timestamp to compare against (milliseconds)\n * @returns true if data is newer, false otherwise\n */\nexport function isDataNewer(\n  wireData: any,\n  fieldName: string,\n  referenceTimestamp: number | null\n): boolean {\n  const dataTimestamp = getHolsterTimestamp(wireData, fieldName);\n  return compareTimestamps(dataTimestamp, referenceTimestamp) > 0;\n}\n\n/**\n * Extract the most recent timestamp from wire data by checking all fields\n * \n * @param wireData - The Holster wire data object\n * @returns The most recent timestamp found, or null if none available\n */\nexport function getMostRecentTimestamp(wireData: any): number | null {\n  try {\n    if (!wireData || !wireData._ || !wireData._[\">\"]) {\n      return null;\n    }\n\n    const stateTimestamps = wireData._[\">\"];\n    let mostRecent: number | null = null;\n\n    for (const field of Object.keys(stateTimestamps)) {\n      const timestamp = stateTimestamps[field];\n      if (typeof timestamp === \"number\") {\n        if (mostRecent === null || timestamp > mostRecent) {\n          mostRecent = timestamp;\n        }\n      }\n    }\n\n    return mostRecent;\n  } catch (error) {\n    console.error(\"[HOLSTER-TIMESTAMP] Error finding most recent timestamp:\", error);\n    return null;\n  }\n}\n\n/**\n * Check if a timestamp is considered \"reliable\"\n * Gun/Holster may use epoch time (0 or very low values) as placeholder\n * \n * @param timestamp - Timestamp to check (milliseconds)\n * @returns true if timestamp appears to be a real value\n */\nexport function isReliableTimestamp(timestamp: number | null): boolean {\n  if (timestamp === null) return false;\n\n  // Consider timestamps after Jan 2, 1970 as reliable\n  const MIN_RELIABLE_TIMESTAMP = new Date(\"1970-01-02T00:00:00.000Z\").getTime();\n  return timestamp > MIN_RELIABLE_TIMESTAMP;\n}\n\n/**\n * Format a timestamp for display\n * \n * @param timestamp - Timestamp in milliseconds\n * @returns ISO string format, or 'Unknown' if null/invalid\n */\nexport function formatTimestamp(timestamp: number | null): string {\n  if (timestamp === null) return \"Unknown\";\n\n  try {\n    return new Date(timestamp).toISOString();\n  } catch (error) {\n    return \"Invalid\";\n  }\n}\n\n/**\n * Extract node ID from wire data\n * \n * @param wireData - The Holster wire data object\n * @returns Node ID or null if unavailable\n */\nexport function getNodeId(wireData: any): string | null {\n  try {\n    return wireData?._?.[\"#\"] || null;\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Create timestamp metadata for persistence\n * Used to track the most recent network timestamps\n */\nexport interface TimestampMetadata {\n  value: number;\n  reliable: boolean;\n  updatedAt: number;\n}\n\n/**\n * Update timestamp metadata with smart validation\n * \n * @param current - Current timestamp metadata (if any)\n * @param newTimestamp - New timestamp from network\n * @returns Updated metadata or null if update should be rejected\n */\nexport function updateTimestampMetadata(\n  current: TimestampMetadata | null,\n  newTimestamp: number | null\n): TimestampMetadata | null {\n  if (newTimestamp === null) {\n    return current;\n  }\n\n  const isReliable = isReliableTimestamp(newTimestamp);\n\n  // If no current metadata, accept the new timestamp\n  if (!current) {\n    return {\n      value: newTimestamp,\n      reliable: isReliable,\n      updatedAt: Date.now(),\n    };\n  }\n\n  // If new timestamp is not reliable, keep current if it's reliable\n  if (!isReliable && current.reliable) {\n    return current;\n  }\n\n  // If new timestamp is newer, update\n  if (newTimestamp > current.value) {\n    return {\n      value: newTimestamp,\n      reliable: isReliable,\n      updatedAt: Date.now(),\n    };\n  }\n\n  return current;\n}\n\n","/**\n * Holster Stream Management\n * Reactive subscription system for real-time RDX data\n */\n\nimport {\n  getHolsterTimestamp,\n  compareTimestamps,\n  isReliableTimestamp,\n  type TimestampMetadata,\n  updateTimestampMetadata,\n} from \"./holster-timestamps.js\";\n\n/**\n * Holster subscription stream using ReadableStream for proper lifecycle management\n */\nexport class HolsterSubscriptionStream<T> {\n  private reader: any = null; // ReadableStreamDefaultReader<T>\n  private stream: ReadableStream<T> | null = null;\n  private isActive = false;\n  private holsterRef: any;\n  private streamId: string;\n\n  constructor(\n    private holsterPath: () => any,\n    private streamType: string,\n    private onData: (data: T) => void,\n    private onError?: (error: any) => void\n  ) {\n    this.streamId = `${streamType}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Start the subscription stream\n   */\n  async start(): Promise<void> {\n    if (this.isActive) {\n      console.warn(`[STREAM] ${this.streamType} stream already active`);\n      return;\n    }\n\n    try {\n      this.isActive = true;\n      console.log(\n        `[STREAM] Starting ${this.streamType} stream ${this.streamId}`\n      );\n\n      this.stream = new ReadableStream<T>({\n        start: (controller) => {\n          try {\n            // Get the Holster reference\n            this.holsterRef = this.holsterPath();\n\n            if (!this.holsterRef) {\n              console.warn(\n                `[STREAM] No Holster reference for ${this.streamType} stream ${this.streamId}`\n              );\n              return;\n            }\n\n            // Set up the Holster subscription using .on()\n            this.holsterRef.on((data: T) => {\n              if (this.isActive) {\n                if (data !== null && data !== undefined) {\n                  controller.enqueue(data);\n                }\n              }\n            });\n\n            console.log(\n              `[STREAM] ${this.streamType} stream ${this.streamId} started successfully`\n            );\n          } catch (error) {\n            console.error(\n              `[STREAM] Error starting ${this.streamType} stream:`,\n              error\n            );\n            controller.error(error);\n            this.onError?.(error);\n          }\n        },\n        cancel: () => {\n          console.log(\n            `[STREAM] Cancelling ${this.streamType} stream ${this.streamId}`\n          );\n          this.cleanup();\n        },\n      });\n\n      // Get the reader and start processing\n      this.reader = this.stream.getReader();\n      this.processStream();\n    } catch (error) {\n      console.error(\n        `[STREAM] Failed to start ${this.streamType} stream:`,\n        error\n      );\n      this.cleanup();\n      this.onError?.(error);\n    }\n  }\n\n  /**\n   * Process the stream data\n   */\n  private async processStream(): Promise<void> {\n    if (!this.reader) return;\n\n    try {\n      while (this.isActive) {\n        const { value, done } = await this.reader.read();\n\n        if (done) {\n          console.log(\n            `[STREAM] ${this.streamType} stream ${this.streamId} completed`\n          );\n          break;\n        }\n\n        if (value && this.isActive) {\n          this.onData(value);\n        }\n      }\n    } catch (error) {\n      if (this.isActive) {\n        console.error(`[STREAM] Error in ${this.streamType} stream:`, error);\n        this.onError?.(error);\n      }\n    } finally {\n      if (!this.isActive) {\n        this.cleanup();\n      }\n    }\n  }\n\n  /**\n   * Stop the subscription stream\n   */\n  stop(): void {\n    if (!this.isActive) return;\n\n    console.log(`[STREAM] Stopping ${this.streamType} stream ${this.streamId}`);\n    this.isActive = false;\n    this.cleanup();\n  }\n\n  /**\n   * Clean up resources\n   */\n  private cleanup(): void {\n    this.isActive = false;\n\n    try {\n      // Cancel the reader\n      if (this.reader) {\n        this.reader.cancel();\n        this.reader = null;\n      }\n\n      // Clean up Holster subscription\n      if (this.holsterRef && typeof this.holsterRef.off === \"function\") {\n        this.holsterRef.off();\n        this.holsterRef = null;\n      }\n\n      this.stream = null;\n      console.log(\n        `[STREAM] Cleaned up ${this.streamType} stream ${this.streamId}`\n      );\n    } catch (error) {\n      console.error(\n        `[STREAM] Error during cleanup of ${this.streamType} stream:`,\n        error\n      );\n    }\n  }\n\n  /**\n   * Check if stream is active\n   */\n  get active(): boolean {\n    return this.isActive;\n  }\n}\n\n/**\n * Stream subscription manager with memoization and delta-based updates\n */\nexport class StreamSubscriptionManager {\n  private activeStreams = new Map<string, HolsterSubscriptionStream<any>>();\n  private subscriptionType: string;\n  private lastContributorsList: string[] = [];\n  private isUpdating = false;\n\n  constructor(subscriptionType: string) {\n    this.subscriptionType = subscriptionType;\n  }\n\n  /**\n   * Create a new subscription stream only if it doesn't already exist\n   */\n  async createStream<T>(\n    contributorId: string,\n    holsterPath: () => any,\n    streamType: string,\n    onData: (data: T) => void,\n    onError?: (error: any) => void\n  ): Promise<void> {\n    const streamKey = `${contributorId}_${streamType}`;\n\n    // Check if stream already exists and is active\n    const existingStream = this.activeStreams.get(streamKey);\n    if (existingStream && existingStream.active) {\n      return;\n    }\n\n    // Stop inactive stream if it exists\n    if (existingStream) {\n      existingStream.stop();\n      this.activeStreams.delete(streamKey);\n    }\n\n    // Create new stream\n    const stream = new HolsterSubscriptionStream(\n      holsterPath,\n      `${this.subscriptionType}_${streamType}`,\n      onData,\n      onError\n    );\n\n    this.activeStreams.set(streamKey, stream);\n\n    try {\n      await stream.start();\n    } catch (error) {\n      this.activeStreams.delete(streamKey);\n      throw error;\n    }\n  }\n\n  /**\n   * Stop a specific stream\n   */\n  stopStream(contributorId: string, streamType: string): void {\n    const streamKey = `${contributorId}_${streamType}`;\n    const stream = this.activeStreams.get(streamKey);\n\n    if (stream) {\n      stream.stop();\n      this.activeStreams.delete(streamKey);\n    }\n  }\n\n  /**\n   * Stop all streams for a contributor\n   */\n  stopContributorStreams(contributorId: string): void {\n    const keysToRemove: string[] = [];\n\n    for (const [streamKey, stream] of this.activeStreams.entries()) {\n      if (streamKey.startsWith(`${contributorId}_`)) {\n        stream.stop();\n        keysToRemove.push(streamKey);\n      }\n    }\n\n    keysToRemove.forEach((key) => this.activeStreams.delete(key));\n  }\n\n  /**\n   * Stop all streams\n   */\n  stopAllStreams(): void {\n    console.log(\n      `[STREAM-MANAGER] Stopping all ${this.subscriptionType} streams`\n    );\n\n    for (const [_streamKey, stream] of this.activeStreams.entries()) {\n      stream.stop();\n    }\n\n    this.activeStreams.clear();\n    this.lastContributorsList = [];\n  }\n\n  /**\n   * Check if contributor lists are equal\n   */\n  private arraysEqual(a: string[], b: string[]): boolean {\n    if (a.length !== b.length) return false;\n    const sortedA = [...a].sort();\n    const sortedB = [...b].sort();\n    return sortedA.every((val, i) => val === sortedB[i]);\n  }\n\n  /**\n   * Update subscriptions using delta-based approach with memoization\n   */\n  async updateSubscriptions(\n    newContributors: string[],\n    createStreamFn: (contributorId: string) => Promise<void>\n  ): Promise<void> {\n    // Prevent concurrent updates\n    if (this.isUpdating) {\n      return;\n    }\n\n    // Check if contributors list has actually changed\n    if (this.arraysEqual(newContributors, this.lastContributorsList)) {\n      return;\n    }\n\n    this.isUpdating = true;\n\n    try {\n      if (!newContributors.length) {\n        this.stopAllStreams();\n        return;\n      }\n\n      console.log(\n        `[STREAM-MANAGER] Updating ${this.subscriptionType} subscriptions for ${newContributors.length} contributors`\n      );\n\n      // Calculate current contributors from active streams\n      const currentContributors = new Set<string>();\n      for (const streamKey of this.activeStreams.keys()) {\n        const contributorId = streamKey.split(\"_\")[0];\n        currentContributors.add(contributorId);\n      }\n\n      const newContributorSet = new Set(newContributors);\n      const toAdd = newContributors.filter(\n        (id) => !currentContributors.has(id)\n      );\n      const toRemove = Array.from(currentContributors).filter(\n        (id) => !newContributorSet.has(id)\n      );\n\n      // Remove old streams\n      for (const contributorId of toRemove) {\n        this.stopContributorStreams(contributorId);\n      }\n\n      // Add new streams\n      for (const contributorId of toAdd) {\n        try {\n          await createStreamFn(contributorId);\n        } catch (error) {\n          console.error(\n            `[STREAM-MANAGER] Failed to create streams for contributor ${contributorId}:`,\n            error\n          );\n        }\n      }\n\n      // Update last contributors list\n      this.lastContributorsList = [...newContributors];\n\n      console.log(\n        `[STREAM-MANAGER] ${this.subscriptionType} streams: +${toAdd.length} -${toRemove.length} (total: ${this.activeStreams.size})`\n      );\n    } finally {\n      this.isUpdating = false;\n    }\n  }\n\n  /**\n   * Get stream count for debugging\n   */\n  get streamCount(): number {\n    return this.activeStreams.size;\n  }\n\n  /**\n   * Get active stream keys for debugging\n   */\n  get activeStreamKeys(): string[] {\n    return Array.from(this.activeStreams.keys());\n  }\n}\n\n/**\n * Data processor with timestamp-based freshness checking\n */\nexport interface DataProcessorConfig<T> {\n  dataType: string;\n  validator?: (data: any) => T | null;\n  getCurrentData: () => T | null;\n  updateStore: (data: T) => void;\n  onUpdate?: () => void;\n  enableTimestampComparison?: boolean;\n  timestampField?: string;\n}\n\n/**\n * Create a data processor with smart timestamp handling\n */\nexport function createDataProcessor<T>(config: DataProcessorConfig<T>) {\n  let lastTimestamp: TimestampMetadata | null = null;\n\n  return (rawData: any) => {\n    const {\n      dataType,\n      validator,\n      getCurrentData,\n      updateStore,\n      onUpdate,\n      enableTimestampComparison,\n      timestampField,\n    } = config;\n\n    if (!rawData) {\n      console.log(`[PROCESSOR] No ${dataType} data found`);\n      return;\n    }\n\n    try {\n      // Apply validator\n      let processedData = rawData;\n      if (validator) {\n        processedData = validator(rawData);\n        if (!processedData) {\n          console.error(`[PROCESSOR] Failed to validate ${dataType} data`);\n          return;\n        }\n      }\n\n      // Get current data for comparison\n      const currentData = getCurrentData();\n\n      // Timestamp-based freshness check\n      if (enableTimestampComparison) {\n        try {\n          const field = timestampField || \"_\";\n          const incomingTimestamp = getHolsterTimestamp(rawData, field);\n\n          if (incomingTimestamp !== null) {\n            const newMetadata = updateTimestampMetadata(\n              lastTimestamp,\n              incomingTimestamp\n            );\n\n            if (newMetadata && newMetadata !== lastTimestamp) {\n              const comparison = compareTimestamps(\n                incomingTimestamp,\n                lastTimestamp?.value || null\n              );\n\n              if (comparison <= 0 && isReliableTimestamp(incomingTimestamp)) {\n                console.log(\n                  `[PROCESSOR] Incoming ${dataType} is older/same, ignoring update`\n                );\n                return;\n              }\n\n              if (isReliableTimestamp(incomingTimestamp)) {\n                console.log(\n                  `[PROCESSOR] Incoming ${dataType} is newer, accepting update`\n                );\n                lastTimestamp = newMetadata;\n              }\n            }\n          }\n        } catch (timestampError) {\n          console.warn(\n            `[PROCESSOR] Error extracting timestamps for ${dataType}:`,\n            timestampError\n          );\n        }\n      }\n\n      // Fallback: JSON-based change detection\n      if (\n        currentData &&\n        JSON.stringify(currentData) === JSON.stringify(processedData)\n      ) {\n        return;\n      }\n\n      console.log(`[PROCESSOR] ${dataType} data changed, updating store`);\n      if (processedData && typeof processedData === \"object\") {\n        updateStore(processedData as T);\n        onUpdate?.();\n      }\n    } catch (error) {\n      console.error(`[PROCESSOR] Error processing ${dataType}:`, error);\n    }\n  };\n}\n"],"names":["WireLabel","value","randomBytes","other","i","Garbler","wireId","label0","label1","labels","gate","encryptedTable","input1_0","input1_1","input2_0","input2_1","output_0","output_1","truthTable","a","b","inputLabel1","inputLabel2","outputLabel","encrypted","plaintext","key1","key2","combined","key","sha256","iv","createCipheriv","table","j","gateType","Evaluator","garbledGate","ciphertext","decrypted","createDecipheriv","label2","result","SecureMinCircuit","bitWidth","aBits","bBits","aWires","bWires","aLessThanB","resultWires","garbledGates","n","bits","_aWires","_bWires","_control","trueWires","_falseWires","secureMinimumGarbled","aInt","bInt","circuit","getHolsterTimestamp","wireData","fieldName","stateTimestamps","timestamp","error","compareTimestamps","timestamp1","timestamp2","isDataNewer","referenceTimestamp","dataTimestamp","getMostRecentTimestamp","mostRecent","field","isReliableTimestamp","MIN_RELIABLE_TIMESTAMP","formatTimestamp","getNodeId","updateTimestampMetadata","current","newTimestamp","isReliable","HolsterSubscriptionStream","holsterPath","streamType","onData","onError","controller","data","done","StreamSubscriptionManager","subscriptionType","contributorId","streamKey","existingStream","stream","keysToRemove","_streamKey","sortedA","sortedB","val","newContributors","createStreamFn","currentContributors","newContributorSet","toAdd","id","toRemove","createDataProcessor","config","lastTimestamp","rawData","dataType","validator","getCurrentData","updateStore","onUpdate","enableTimestampComparison","timestampField","processedData","currentData","incomingTimestamp","newMetadata","timestampError"],"mappings":"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"}