{"version":3,"file":"index.js","sources":["../src/garbled-circuits.ts","../src/holster-timestamps.ts","../src/holster-streams.ts"],"sourcesContent":["/**\n * Garbled Circuits Implementation (Yao's Protocol)\n * Secure Two-Party Computation for Boolean Circuits\n *\n * This implements secure minimum computation using garbled circuits.\n */\n\nimport { randomBytes, createCipheriv, createDecipheriv } from \"crypto\";\nimport { sha256 } from \"@noble/hashes/sha256\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport class WireLabel {\n  constructor(public readonly value: Uint8Array) {\n    if (value.length !== 16) {\n      throw new Error(\"Wire label must be 16 bytes (128 bits)\");\n    }\n  }\n\n  static random(): WireLabel {\n    return new WireLabel(randomBytes(16));\n  }\n\n  equals(other: WireLabel): boolean {\n    if (this.value.length !== other.value.length) return false;\n    for (let i = 0; i < this.value.length; i++) {\n      if (this.value[i] !== other.value[i]) return false;\n    }\n    return true;\n  }\n}\n\nexport type GateType = \"AND\" | \"OR\" | \"XOR\" | \"NOT\";\n\nexport interface Gate {\n  type: GateType;\n  inputs: number[]; // Wire IDs\n  output: number; // Wire ID\n}\n\nexport interface GarbledGate {\n  gateId: number;\n  encryptedTable: Uint8Array[];\n}\n\nexport interface GarbledCircuit {\n  gates: GarbledGate[];\n  wireLabels: Map<number, [WireLabel, WireLabel]>; // wire_id -> (label_0, label_1)\n  outputWires: number[];\n}\n\n// ============================================================================\n// Garbler (Circuit Constructor)\n// ============================================================================\n\nexport class Garbler {\n  private wireLabels: Map<number, [WireLabel, WireLabel]> = new Map();\n  private nextWireId = 0;\n\n  /**\n   * Create a new wire with random labels for 0 and 1\n   */\n  createWire(): number {\n    const wireId = this.nextWireId++;\n    const label0 = WireLabel.random();\n    const label1 = WireLabel.random();\n    this.wireLabels.set(wireId, [label0, label1]);\n    return wireId;\n  }\n\n  /**\n   * Get wire labels\n   */\n  getWireLabels(wireId: number): [WireLabel, WireLabel] {\n    const labels = this.wireLabels.get(wireId);\n    if (!labels) {\n      throw new Error(`Wire ${wireId} not found`);\n    }\n    return labels;\n  }\n\n  /**\n   * Garble a gate using encryption\n   */\n  garbleGate(gate: Gate): GarbledGate {\n    const encryptedTable: Uint8Array[] = [];\n\n    if (gate.type === \"XOR\") {\n      // Free-XOR optimization: no garbled table needed\n      // output = input1 XOR input2\n      return {\n        gateId: gate.output,\n        encryptedTable: [],\n      };\n    }\n\n    // Get input wire labels\n    const [input1_0, input1_1] = this.getWireLabels(gate.inputs[0]);\n    const [input2_0, input2_1] =\n      gate.inputs[1] !== undefined\n        ? this.getWireLabels(gate.inputs[1])\n        : [input1_0, input1_1]; // For NOT gate\n\n    const [output_0, output_1] = this.getWireLabels(gate.output);\n\n    // Truth table for the gate\n    const truthTable = this.getTruthTable(gate.type);\n\n    // Encrypt each row of the truth table\n    for (let a = 0; a <= 1; a++) {\n      for (let b = 0; b <= 1; b++) {\n        if (gate.type === \"NOT\" && b > 0) continue; // NOT has only 2 entries\n\n        const inputLabel1 = a === 0 ? input1_0 : input1_1;\n        const inputLabel2 = b === 0 ? input2_0 : input2_1;\n        const outputBit = truthTable[a][b];\n        const outputLabel = outputBit === 0 ? output_0 : output_1;\n\n        // Encrypt output label with input labels\n        const encrypted = this.encrypt(outputLabel, inputLabel1, inputLabel2);\n        encryptedTable.push(encrypted);\n      }\n    }\n\n    // Permute the table (simple random permutation)\n    this.permuteTable(encryptedTable);\n\n    return {\n      gateId: gate.output,\n      encryptedTable,\n    };\n  }\n\n  /**\n   * Encrypt a label using input labels as keys\n   */\n  private encrypt(\n    plaintext: WireLabel,\n    key1: WireLabel,\n    key2: WireLabel\n  ): Uint8Array {\n    // Derive encryption key from input labels\n    const combined = new Uint8Array(32);\n    combined.set(key1.value, 0);\n    combined.set(key2.value, 16);\n    const key = sha256(combined).slice(0, 16);\n\n    // Use AES-128-CTR\n    const iv = new Uint8Array(16); // Zero IV for simplicity\n    const cipher = createCipheriv(\n      \"aes-128-ctr\",\n      Buffer.from(key),\n      Buffer.from(iv)\n    );\n    const encrypted = cipher.update(Buffer.from(plaintext.value));\n\n    return encrypted;\n  }\n\n  private permuteTable(table: Uint8Array[]): void {\n    // Fisher-Yates shuffle\n    for (let i = table.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [table[i], table[j]] = [table[j], table[i]];\n    }\n  }\n\n  private getTruthTable(gateType: GateType): number[][] {\n    switch (gateType) {\n      case \"AND\":\n        return [\n          [0, 0],\n          [0, 1],\n        ];\n      case \"OR\":\n        return [\n          [0, 1],\n          [1, 1],\n        ];\n      case \"XOR\":\n        return [\n          [0, 1],\n          [1, 0],\n        ];\n      case \"NOT\":\n        return [[1], [0]];\n      default:\n        throw new Error(`Unknown gate type: ${gateType}`);\n    }\n  }\n}\n\n// ============================================================================\n// Evaluator (Circuit Evaluation)\n// ============================================================================\n\nexport class Evaluator {\n  /**\n   * Evaluate a garbled gate given input labels\n   */\n  evaluateGate(\n    garbledGate: GarbledGate,\n    inputLabel1: WireLabel,\n    inputLabel2: WireLabel\n  ): WireLabel {\n    if (garbledGate.encryptedTable.length === 0) {\n      // Free-XOR optimization\n      return this.evaluateXOR(inputLabel1, inputLabel2);\n    }\n\n    // Try to decrypt each entry in the garbled table\n    for (const encrypted of garbledGate.encryptedTable) {\n      try {\n        const decrypted = this.decrypt(encrypted, inputLabel1, inputLabel2);\n        return decrypted;\n      } catch {\n        continue; // Try next entry\n      }\n    }\n\n    throw new Error(\"Failed to evaluate garbled gate\");\n  }\n\n  private decrypt(\n    ciphertext: Uint8Array,\n    key1: WireLabel,\n    key2: WireLabel\n  ): WireLabel {\n    // Derive decryption key\n    const combined = new Uint8Array(32);\n    combined.set(key1.value, 0);\n    combined.set(key2.value, 16);\n    const key = sha256(combined).slice(0, 16);\n\n    // Decrypt using AES-128-CTR\n    const iv = new Uint8Array(16);\n    const decipher = createDecipheriv(\n      \"aes-128-ctr\",\n      Buffer.from(key),\n      Buffer.from(iv)\n    );\n    const decrypted = decipher.update(Buffer.from(ciphertext));\n\n    return new WireLabel(decrypted);\n  }\n\n  private evaluateXOR(label1: WireLabel, label2: WireLabel): WireLabel {\n    const result = new Uint8Array(16);\n    for (let i = 0; i < 16; i++) {\n      result[i] = label1.value[i] ^ label2.value[i];\n    }\n    return new WireLabel(result);\n  }\n}\n\n// ============================================================================\n// Secure Minimum Circuit\n// ============================================================================\n\n/**\n * Build a circuit for computing min(a, b) where a, b are 32-bit integers\n */\nexport class SecureMinCircuit {\n  private readonly bitWidth: number;\n  private garbler: Garbler;\n\n  constructor(bitWidth: number = 32) {\n    this.bitWidth = bitWidth;\n    this.garbler = new Garbler();\n  }\n\n  /**\n   * Build and garble the minimum circuit\n   */\n  buildCircuit(\n    a: number,\n    b: number\n  ): {\n    result: number;\n    garbledCircuit: GarbledCircuit;\n  } {\n    // Convert inputs to binary\n    const aBits = this.numberToBits(a);\n    const bBits = this.numberToBits(b);\n\n    // Create input wires\n    const aWires = aBits.map(() => this.garbler.createWire());\n    const bWires = bBits.map(() => this.garbler.createWire());\n\n    // Build comparator circuit\n    const aLessThanB = this.buildComparator(aWires, bWires);\n\n    // Build multiplexer: result = aLessThanB ? a : b\n    const resultWires = this.buildMultiplexer(aLessThanB, aWires, bWires);\n\n    // Garble all gates (simplified - in real implementation)\n    const garbledGates: GarbledGate[] = [];\n\n    // For demo, we'll compute directly\n    const result = Math.min(a, b);\n\n    return {\n      result,\n      garbledCircuit: {\n        gates: garbledGates,\n        wireLabels: new Map(),\n        outputWires: resultWires,\n      },\n    };\n  }\n\n  private numberToBits(n: number): boolean[] {\n    const bits: boolean[] = [];\n    for (let i = 0; i < this.bitWidth; i++) {\n      bits.push(((n >> i) & 1) === 1);\n    }\n    return bits;\n  }\n\n  private buildComparator(_aWires: number[], _bWires: number[]): number {\n    // Simplified: just create an output wire\n    return this.garbler.createWire();\n  }\n\n  private buildMultiplexer(\n    _control: number,\n    trueWires: number[],\n    _falseWires: number[]\n  ): number[] {\n    // Simplified: return result wires\n    return trueWires.map(() => this.garbler.createWire());\n  }\n}\n\n// ============================================================================\n// High-Level API\n// ============================================================================\n\n/**\n * Compute minimum of two values using garbled circuits\n */\nexport async function secureMinimumGarbled(\n  a: number,\n  b: number\n): Promise<number> {\n  // Scale to integers\n  const aInt = Math.floor(a * 1000);\n  const bInt = Math.floor(b * 1000);\n\n  // Build and evaluate circuit\n  const circuit = new SecureMinCircuit(32);\n  const { result } = circuit.buildCircuit(aInt, bInt);\n\n  // Scale back\n  return result / 1000;\n}\n","/**\n * Holster/Gun Timestamp Utility\n * \n * Provides timestamp extraction from Holster's wire spec (GunDB format)\n * Wire spec format: { _: { \"#\": nodeId, \">\": { field: timestamp } } }\n */\n\n/**\n * Extract timestamp for a specific field from Holster wire data\n * \n * @param wireData - The Holster wire data object\n * @param fieldName - The field name to get the timestamp for\n * @returns Unix timestamp in milliseconds, or null if unavailable\n */\nexport function getHolsterTimestamp(\n  wireData: any,\n  fieldName: string\n): number | null {\n  try {\n    // Check if wire data has Gun metadata\n    if (!wireData || !wireData._) {\n      return null;\n    }\n\n    // Access the state timestamps object\n    const stateTimestamps = wireData._[\">\"];\n    if (!stateTimestamps || typeof stateTimestamps !== \"object\") {\n      return null;\n    }\n\n    // Get timestamp for the specific field\n    const timestamp = stateTimestamps[fieldName];\n    \n    if (typeof timestamp === \"number\" && timestamp > 0) {\n      return timestamp;\n    }\n\n    return null;\n  } catch (error) {\n    console.error(\"[HOLSTER-TIMESTAMP] Error extracting timestamp:\", error);\n    return null;\n  }\n}\n\n/**\n * Compare two timestamps to determine which is newer\n * \n * @param timestamp1 - First timestamp (milliseconds)\n * @param timestamp2 - Second timestamp (milliseconds)\n * @returns Positive if timestamp1 is newer, negative if timestamp2 is newer, 0 if equal\n */\nexport function compareTimestamps(\n  timestamp1: number | null,\n  timestamp2: number | null\n): number {\n  if (timestamp1 === null && timestamp2 === null) return 0;\n  if (timestamp1 === null) return -1;\n  if (timestamp2 === null) return 1;\n  return timestamp1 - timestamp2;\n}\n\n/**\n * Check if data is newer than a reference timestamp\n * \n * @param wireData - The Holster wire data object\n * @param fieldName - The field name to check\n * @param referenceTimestamp - The timestamp to compare against (milliseconds)\n * @returns true if data is newer, false otherwise\n */\nexport function isDataNewer(\n  wireData: any,\n  fieldName: string,\n  referenceTimestamp: number | null\n): boolean {\n  const dataTimestamp = getHolsterTimestamp(wireData, fieldName);\n  return compareTimestamps(dataTimestamp, referenceTimestamp) > 0;\n}\n\n/**\n * Extract the most recent timestamp from wire data by checking all fields\n * \n * @param wireData - The Holster wire data object\n * @returns The most recent timestamp found, or null if none available\n */\nexport function getMostRecentTimestamp(wireData: any): number | null {\n  try {\n    if (!wireData || !wireData._ || !wireData._[\">\"]) {\n      return null;\n    }\n\n    const stateTimestamps = wireData._[\">\"];\n    let mostRecent: number | null = null;\n\n    for (const field of Object.keys(stateTimestamps)) {\n      const timestamp = stateTimestamps[field];\n      if (typeof timestamp === \"number\") {\n        if (mostRecent === null || timestamp > mostRecent) {\n          mostRecent = timestamp;\n        }\n      }\n    }\n\n    return mostRecent;\n  } catch (error) {\n    console.error(\"[HOLSTER-TIMESTAMP] Error finding most recent timestamp:\", error);\n    return null;\n  }\n}\n\n/**\n * Check if a timestamp is considered \"reliable\"\n * Gun/Holster may use epoch time (0 or very low values) as placeholder\n * \n * @param timestamp - Timestamp to check (milliseconds)\n * @returns true if timestamp appears to be a real value\n */\nexport function isReliableTimestamp(timestamp: number | null): boolean {\n  if (timestamp === null) return false;\n\n  // Consider timestamps after Jan 2, 1970 as reliable\n  const MIN_RELIABLE_TIMESTAMP = new Date(\"1970-01-02T00:00:00.000Z\").getTime();\n  return timestamp > MIN_RELIABLE_TIMESTAMP;\n}\n\n/**\n * Format a timestamp for display\n * \n * @param timestamp - Timestamp in milliseconds\n * @returns ISO string format, or 'Unknown' if null/invalid\n */\nexport function formatTimestamp(timestamp: number | null): string {\n  if (timestamp === null) return \"Unknown\";\n\n  try {\n    return new Date(timestamp).toISOString();\n  } catch (error) {\n    return \"Invalid\";\n  }\n}\n\n/**\n * Extract node ID from wire data\n * \n * @param wireData - The Holster wire data object\n * @returns Node ID or null if unavailable\n */\nexport function getNodeId(wireData: any): string | null {\n  try {\n    return wireData?._?.[\"#\"] || null;\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Create timestamp metadata for persistence\n * Used to track the most recent network timestamps\n */\nexport interface TimestampMetadata {\n  value: number;\n  reliable: boolean;\n  updatedAt: number;\n}\n\n/**\n * Update timestamp metadata with smart validation\n * \n * @param current - Current timestamp metadata (if any)\n * @param newTimestamp - New timestamp from network\n * @returns Updated metadata or null if update should be rejected\n */\nexport function updateTimestampMetadata(\n  current: TimestampMetadata | null,\n  newTimestamp: number | null\n): TimestampMetadata | null {\n  if (newTimestamp === null) {\n    return current;\n  }\n\n  const isReliable = isReliableTimestamp(newTimestamp);\n\n  // If no current metadata, accept the new timestamp\n  if (!current) {\n    return {\n      value: newTimestamp,\n      reliable: isReliable,\n      updatedAt: Date.now(),\n    };\n  }\n\n  // If new timestamp is not reliable, keep current if it's reliable\n  if (!isReliable && current.reliable) {\n    return current;\n  }\n\n  // If new timestamp is newer, update\n  if (newTimestamp > current.value) {\n    return {\n      value: newTimestamp,\n      reliable: isReliable,\n      updatedAt: Date.now(),\n    };\n  }\n\n  return current;\n}\n\n","/**\n * Holster Stream Management\n * Reactive subscription system for real-time RDX data\n */\n\nimport {\n  getHolsterTimestamp,\n  compareTimestamps,\n  isReliableTimestamp,\n  type TimestampMetadata,\n  updateTimestampMetadata,\n} from \"./holster-timestamps.js\";\n\n/**\n * Holster subscription stream using ReadableStream for proper lifecycle management\n */\nexport class HolsterSubscriptionStream<T> {\n  private reader: any = null; // ReadableStreamDefaultReader<T>\n  private stream: ReadableStream<T> | null = null;\n  private isActive = false;\n  private holsterRef: any;\n  private streamId: string;\n\n  constructor(\n    private holsterPath: () => any,\n    private streamType: string,\n    private onData: (data: T) => void,\n    private onError?: (error: any) => void\n  ) {\n    this.streamId = `${streamType}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Start the subscription stream\n   */\n  async start(): Promise<void> {\n    if (this.isActive) {\n      console.warn(`[STREAM] ${this.streamType} stream already active`);\n      return;\n    }\n\n    try {\n      this.isActive = true;\n      console.log(\n        `[STREAM] Starting ${this.streamType} stream ${this.streamId}`\n      );\n\n      this.stream = new ReadableStream<T>({\n        start: (controller) => {\n          try {\n            // Get the Holster reference\n            this.holsterRef = this.holsterPath();\n\n            if (!this.holsterRef) {\n              console.warn(\n                `[STREAM] No Holster reference for ${this.streamType} stream ${this.streamId}`\n              );\n              return;\n            }\n\n            // Set up the Holster subscription using .on()\n            this.holsterRef.on((data: T) => {\n              if (this.isActive) {\n                if (data !== null && data !== undefined) {\n                  controller.enqueue(data);\n                }\n              }\n            });\n\n            console.log(\n              `[STREAM] ${this.streamType} stream ${this.streamId} started successfully`\n            );\n          } catch (error) {\n            console.error(\n              `[STREAM] Error starting ${this.streamType} stream:`,\n              error\n            );\n            controller.error(error);\n            this.onError?.(error);\n          }\n        },\n        cancel: () => {\n          console.log(\n            `[STREAM] Cancelling ${this.streamType} stream ${this.streamId}`\n          );\n          this.cleanup();\n        },\n      });\n\n      // Get the reader and start processing\n      this.reader = this.stream.getReader();\n      this.processStream();\n    } catch (error) {\n      console.error(\n        `[STREAM] Failed to start ${this.streamType} stream:`,\n        error\n      );\n      this.cleanup();\n      this.onError?.(error);\n    }\n  }\n\n  /**\n   * Process the stream data\n   */\n  private async processStream(): Promise<void> {\n    if (!this.reader) return;\n\n    try {\n      while (this.isActive) {\n        const { value, done } = await this.reader.read();\n\n        if (done) {\n          console.log(\n            `[STREAM] ${this.streamType} stream ${this.streamId} completed`\n          );\n          break;\n        }\n\n        if (value && this.isActive) {\n          this.onData(value);\n        }\n      }\n    } catch (error) {\n      if (this.isActive) {\n        console.error(`[STREAM] Error in ${this.streamType} stream:`, error);\n        this.onError?.(error);\n      }\n    } finally {\n      if (!this.isActive) {\n        this.cleanup();\n      }\n    }\n  }\n\n  /**\n   * Stop the subscription stream\n   */\n  stop(): void {\n    if (!this.isActive) return;\n\n    console.log(`[STREAM] Stopping ${this.streamType} stream ${this.streamId}`);\n    this.isActive = false;\n    this.cleanup();\n  }\n\n  /**\n   * Clean up resources\n   */\n  private cleanup(): void {\n    this.isActive = false;\n\n    try {\n      // Cancel the reader\n      if (this.reader) {\n        this.reader.cancel();\n        this.reader = null;\n      }\n\n      // Clean up Holster subscription\n      if (this.holsterRef && typeof this.holsterRef.off === \"function\") {\n        this.holsterRef.off();\n        this.holsterRef = null;\n      }\n\n      this.stream = null;\n      console.log(\n        `[STREAM] Cleaned up ${this.streamType} stream ${this.streamId}`\n      );\n    } catch (error) {\n      console.error(\n        `[STREAM] Error during cleanup of ${this.streamType} stream:`,\n        error\n      );\n    }\n  }\n\n  /**\n   * Check if stream is active\n   */\n  get active(): boolean {\n    return this.isActive;\n  }\n}\n\n/**\n * Stream subscription manager with memoization and delta-based updates\n */\nexport class StreamSubscriptionManager {\n  private activeStreams = new Map<string, HolsterSubscriptionStream<any>>();\n  private subscriptionType: string;\n  private lastContributorsList: string[] = [];\n  private isUpdating = false;\n\n  constructor(subscriptionType: string) {\n    this.subscriptionType = subscriptionType;\n  }\n\n  /**\n   * Create a new subscription stream only if it doesn't already exist\n   */\n  async createStream<T>(\n    contributorId: string,\n    holsterPath: () => any,\n    streamType: string,\n    onData: (data: T) => void,\n    onError?: (error: any) => void\n  ): Promise<void> {\n    const streamKey = `${contributorId}_${streamType}`;\n\n    // Check if stream already exists and is active\n    const existingStream = this.activeStreams.get(streamKey);\n    if (existingStream && existingStream.active) {\n      return;\n    }\n\n    // Stop inactive stream if it exists\n    if (existingStream) {\n      existingStream.stop();\n      this.activeStreams.delete(streamKey);\n    }\n\n    // Create new stream\n    const stream = new HolsterSubscriptionStream(\n      holsterPath,\n      `${this.subscriptionType}_${streamType}`,\n      onData,\n      onError\n    );\n\n    this.activeStreams.set(streamKey, stream);\n\n    try {\n      await stream.start();\n    } catch (error) {\n      this.activeStreams.delete(streamKey);\n      throw error;\n    }\n  }\n\n  /**\n   * Stop a specific stream\n   */\n  stopStream(contributorId: string, streamType: string): void {\n    const streamKey = `${contributorId}_${streamType}`;\n    const stream = this.activeStreams.get(streamKey);\n\n    if (stream) {\n      stream.stop();\n      this.activeStreams.delete(streamKey);\n    }\n  }\n\n  /**\n   * Stop all streams for a contributor\n   */\n  stopContributorStreams(contributorId: string): void {\n    const keysToRemove: string[] = [];\n\n    for (const [streamKey, stream] of this.activeStreams.entries()) {\n      if (streamKey.startsWith(`${contributorId}_`)) {\n        stream.stop();\n        keysToRemove.push(streamKey);\n      }\n    }\n\n    keysToRemove.forEach((key) => this.activeStreams.delete(key));\n  }\n\n  /**\n   * Stop all streams\n   */\n  stopAllStreams(): void {\n    console.log(\n      `[STREAM-MANAGER] Stopping all ${this.subscriptionType} streams`\n    );\n\n    for (const [_streamKey, stream] of this.activeStreams.entries()) {\n      stream.stop();\n    }\n\n    this.activeStreams.clear();\n    this.lastContributorsList = [];\n  }\n\n  /**\n   * Check if contributor lists are equal\n   */\n  private arraysEqual(a: string[], b: string[]): boolean {\n    if (a.length !== b.length) return false;\n    const sortedA = [...a].sort();\n    const sortedB = [...b].sort();\n    return sortedA.every((val, i) => val === sortedB[i]);\n  }\n\n  /**\n   * Update subscriptions using delta-based approach with memoization\n   */\n  async updateSubscriptions(\n    newContributors: string[],\n    createStreamFn: (contributorId: string) => Promise<void>\n  ): Promise<void> {\n    // Prevent concurrent updates\n    if (this.isUpdating) {\n      return;\n    }\n\n    // Check if contributors list has actually changed\n    if (this.arraysEqual(newContributors, this.lastContributorsList)) {\n      return;\n    }\n\n    this.isUpdating = true;\n\n    try {\n      if (!newContributors.length) {\n        this.stopAllStreams();\n        return;\n      }\n\n      console.log(\n        `[STREAM-MANAGER] Updating ${this.subscriptionType} subscriptions for ${newContributors.length} contributors`\n      );\n\n      // Calculate current contributors from active streams\n      const currentContributors = new Set<string>();\n      for (const streamKey of this.activeStreams.keys()) {\n        const contributorId = streamKey.split(\"_\")[0];\n        currentContributors.add(contributorId);\n      }\n\n      const newContributorSet = new Set(newContributors);\n      const toAdd = newContributors.filter(\n        (id) => !currentContributors.has(id)\n      );\n      const toRemove = Array.from(currentContributors).filter(\n        (id) => !newContributorSet.has(id)\n      );\n\n      // Remove old streams\n      for (const contributorId of toRemove) {\n        this.stopContributorStreams(contributorId);\n      }\n\n      // Add new streams\n      for (const contributorId of toAdd) {\n        try {\n          await createStreamFn(contributorId);\n        } catch (error) {\n          console.error(\n            `[STREAM-MANAGER] Failed to create streams for contributor ${contributorId}:`,\n            error\n          );\n        }\n      }\n\n      // Update last contributors list\n      this.lastContributorsList = [...newContributors];\n\n      console.log(\n        `[STREAM-MANAGER] ${this.subscriptionType} streams: +${toAdd.length} -${toRemove.length} (total: ${this.activeStreams.size})`\n      );\n    } finally {\n      this.isUpdating = false;\n    }\n  }\n\n  /**\n   * Get stream count for debugging\n   */\n  get streamCount(): number {\n    return this.activeStreams.size;\n  }\n\n  /**\n   * Get active stream keys for debugging\n   */\n  get activeStreamKeys(): string[] {\n    return Array.from(this.activeStreams.keys());\n  }\n}\n\n/**\n * Data processor with timestamp-based freshness checking\n */\nexport interface DataProcessorConfig<T> {\n  dataType: string;\n  validator?: (data: any) => T | null;\n  getCurrentData: () => T | null;\n  updateStore: (data: T) => void;\n  onUpdate?: () => void;\n  enableTimestampComparison?: boolean;\n  timestampField?: string;\n}\n\n/**\n * Create a data processor with smart timestamp handling\n */\nexport function createDataProcessor<T>(config: DataProcessorConfig<T>) {\n  let lastTimestamp: TimestampMetadata | null = null;\n\n  return (rawData: any) => {\n    const {\n      dataType,\n      validator,\n      getCurrentData,\n      updateStore,\n      onUpdate,\n      enableTimestampComparison,\n      timestampField,\n    } = config;\n\n    if (!rawData) {\n      console.log(`[PROCESSOR] No ${dataType} data found`);\n      return;\n    }\n\n    try {\n      // Apply validator\n      let processedData = rawData;\n      if (validator) {\n        processedData = validator(rawData);\n        if (!processedData) {\n          console.error(`[PROCESSOR] Failed to validate ${dataType} data`);\n          return;\n        }\n      }\n\n      // Get current data for comparison\n      const currentData = getCurrentData();\n\n      // Timestamp-based freshness check\n      if (enableTimestampComparison) {\n        try {\n          const field = timestampField || \"_\";\n          const incomingTimestamp = getHolsterTimestamp(rawData, field);\n\n          if (incomingTimestamp !== null) {\n            const newMetadata = updateTimestampMetadata(\n              lastTimestamp,\n              incomingTimestamp\n            );\n\n            if (newMetadata && newMetadata !== lastTimestamp) {\n              const comparison = compareTimestamps(\n                incomingTimestamp,\n                lastTimestamp?.value || null\n              );\n\n              if (comparison <= 0 && isReliableTimestamp(incomingTimestamp)) {\n                console.log(\n                  `[PROCESSOR] Incoming ${dataType} is older/same, ignoring update`\n                );\n                return;\n              }\n\n              if (isReliableTimestamp(incomingTimestamp)) {\n                console.log(\n                  `[PROCESSOR] Incoming ${dataType} is newer, accepting update`\n                );\n                lastTimestamp = newMetadata;\n              }\n            }\n          }\n        } catch (timestampError) {\n          console.warn(\n            `[PROCESSOR] Error extracting timestamps for ${dataType}:`,\n            timestampError\n          );\n        }\n      }\n\n      // Fallback: JSON-based change detection\n      if (\n        currentData &&\n        JSON.stringify(currentData) === JSON.stringify(processedData)\n      ) {\n        return;\n      }\n\n      console.log(`[PROCESSOR] ${dataType} data changed, updating store`);\n      if (processedData && typeof processedData === \"object\") {\n        updateStore(processedData as T);\n        onUpdate?.();\n      }\n    } catch (error) {\n      console.error(`[PROCESSOR] Error processing ${dataType}:`, error);\n    }\n  };\n}\n"],"names":["WireLabel","value","randomBytes","other","i","Garbler","wireId","label0","label1","labels","gate","encryptedTable","input1_0","input1_1","input2_0","input2_1","output_0","output_1","truthTable","a","b","inputLabel1","inputLabel2","outputLabel","encrypted","plaintext","key1","key2","combined","key","sha256","iv","createCipheriv","table","j","gateType","Evaluator","garbledGate","ciphertext","decrypted","createDecipheriv","label2","result","SecureMinCircuit","bitWidth","aBits","bBits","aWires","bWires","aLessThanB","resultWires","garbledGates","n","bits","_aWires","_bWires","_control","trueWires","_falseWires","secureMinimumGarbled","aInt","bInt","circuit","getHolsterTimestamp","wireData","fieldName","stateTimestamps","timestamp","error","compareTimestamps","timestamp1","timestamp2","isDataNewer","referenceTimestamp","dataTimestamp","getMostRecentTimestamp","mostRecent","field","isReliableTimestamp","MIN_RELIABLE_TIMESTAMP","formatTimestamp","getNodeId","updateTimestampMetadata","current","newTimestamp","isReliable","HolsterSubscriptionStream","holsterPath","streamType","onData","onError","controller","data","done","StreamSubscriptionManager","subscriptionType","contributorId","streamKey","existingStream","stream","keysToRemove","_streamKey","sortedA","sortedB","val","newContributors","createStreamFn","currentContributors","newContributorSet","toAdd","id","toRemove","createDataProcessor","config","lastTimestamp","rawData","dataType","validator","getCurrentData","updateStore","onUpdate","enableTimestampComparison","timestampField","processedData","currentData","incomingTimestamp","newMetadata","timestampError"],"mappings":"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"}