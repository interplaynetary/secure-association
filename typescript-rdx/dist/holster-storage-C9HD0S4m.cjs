"use strict";const Zt=require("crypto"),oe=require("secrets.js-grempe"),m=require("zod"),gt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ct(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function kt(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function mt(n,...t){if(!Ct(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error("Uint8Array expected of length "+t+", got length="+n.length)}function ye(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");kt(n.outputLen),kt(n.blockLen)}function zt(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function un(n,t){mt(n);const r=t.outputLen;if(n.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}function Dt(...n){for(let t=0;t<n.length;t++)n[t].fill(0)}function Mt(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function Q(n,t){return n<<32-t|n>>>t}const be=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",fn=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function yt(n){if(mt(n),be)return n.toHex();let t="";for(let r=0;r<n.length;r++)t+=fn[n[r]];return t}const J={_0:48,_9:57,A:65,F:70,a:97,f:102};function se(n){if(n>=J._0&&n<=J._9)return n-J._0;if(n>=J.A&&n<=J.F)return n-(J.A-10);if(n>=J.a&&n<=J.f)return n-(J.a-10)}function Rt(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(be)return Uint8Array.fromHex(n);const t=n.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const e=new Uint8Array(r);for(let i=0,o=0;i<r;i++,o+=2){const s=se(n.charCodeAt(o)),c=se(n.charCodeAt(o+1));if(s===void 0||c===void 0){const a=n[o]+n[o+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+o)}e[i]=s*16+c}return e}function dn(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function Yt(n){return typeof n=="string"&&(n=dn(n)),mt(n),n}function ot(...n){let t=0;for(let e=0;e<n.length;e++){const i=n[e];mt(i),t+=i.length}const r=new Uint8Array(t);for(let e=0,i=0;e<n.length;e++){const o=n[e];r.set(o,i),i+=o.length}return r}class we{}function hn(n){const t=e=>n().update(Yt(e)).digest(),r=n();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>n(),t}function Ee(n=32){if(gt&&typeof gt.getRandomValues=="function")return gt.getRandomValues(new Uint8Array(n));if(gt&&typeof gt.randomBytes=="function")return Uint8Array.from(gt.randomBytes(n));throw new Error("crypto.getRandomValues must be defined")}function mn(n,t,r,e){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,r,e);const i=BigInt(32),o=BigInt(4294967295),s=Number(r>>i&o),c=Number(r&o),a=e?4:0,f=e?0:4;n.setUint32(t+a,s,e),n.setUint32(t+f,c,e)}function gn(n,t,r){return n&t^~n&r}function pn(n,t,r){return n&t^n&r^t&r}class yn extends we{constructor(t,r,e,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=r,this.padOffset=e,this.isLE=i,this.buffer=new Uint8Array(t),this.view=Mt(this.buffer)}update(t){zt(this),t=Yt(t),mt(t);const{view:r,buffer:e,blockLen:i}=this,o=t.length;for(let s=0;s<o;){const c=Math.min(i-this.pos,o-s);if(c===i){const a=Mt(t);for(;i<=o-s;s+=i)this.process(a,s);continue}e.set(t.subarray(s,s+c),this.pos),this.pos+=c,s+=c,this.pos===i&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){zt(this),un(t,this),this.finished=!0;const{buffer:r,view:e,blockLen:i,isLE:o}=this;let{pos:s}=this;r[s++]=128,Dt(this.buffer.subarray(s)),this.padOffset>i-s&&(this.process(e,0),s=0);for(let d=s;d<i;d++)r[d]=0;mn(e,i-8,BigInt(this.length*8),o),this.process(e,0);const c=Mt(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=a/4,y=this.get();if(f>y.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<f;d++)c.setUint32(4*d,y[d],o)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const e=t.slice(0,r);return this.destroy(),e}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:e,length:i,finished:o,destroyed:s,pos:c}=this;return t.destroyed=s,t.finished=o,t.length=i,t.pos=c,i%r&&t.buffer.set(e),t}clone(){return this._cloneInto()}}const rt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),bn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),it=new Uint32Array(64);class wn extends yn{constructor(t=32){super(64,t,8,!1),this.A=rt[0]|0,this.B=rt[1]|0,this.C=rt[2]|0,this.D=rt[3]|0,this.E=rt[4]|0,this.F=rt[5]|0,this.G=rt[6]|0,this.H=rt[7]|0}get(){const{A:t,B:r,C:e,D:i,E:o,F:s,G:c,H:a}=this;return[t,r,e,i,o,s,c,a]}set(t,r,e,i,o,s,c,a){this.A=t|0,this.B=r|0,this.C=e|0,this.D=i|0,this.E=o|0,this.F=s|0,this.G=c|0,this.H=a|0}process(t,r){for(let d=0;d<16;d++,r+=4)it[d]=t.getUint32(r,!1);for(let d=16;d<64;d++){const l=it[d-15],u=it[d-2],w=Q(l,7)^Q(l,18)^l>>>3,E=Q(u,17)^Q(u,19)^u>>>10;it[d]=E+it[d-7]+w+it[d-16]|0}let{A:e,B:i,C:o,D:s,E:c,F:a,G:f,H:y}=this;for(let d=0;d<64;d++){const l=Q(c,6)^Q(c,11)^Q(c,25),u=y+l+gn(c,a,f)+bn[d]+it[d]|0,E=(Q(e,2)^Q(e,13)^Q(e,22))+pn(e,i,o)|0;y=f,f=a,a=c,c=s+u|0,s=o,o=i,i=e,e=u+E|0}e=e+this.A|0,i=i+this.B|0,o=o+this.C|0,s=s+this.D|0,c=c+this.E|0,a=a+this.F|0,f=f+this.G|0,y=y+this.H|0,this.set(e,i,o,s,c,a,f,y)}roundClean(){Dt(it)}destroy(){this.set(0,0,0,0,0,0,0,0),Dt(this.buffer)}}const ve=hn(()=>new wn);class Se extends we{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,ye(t);const e=Yt(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,o=new Uint8Array(i);o.set(e.length>i?t.create().update(e).digest():e);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=t.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),Dt(o)}update(t){return zt(this),this.iHash.update(t),this}digestInto(t){zt(this),mt(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:e,finished:i,destroyed:o,blockLen:s,outputLen:c}=this;return t=t,t.finished=i,t.destroyed=o,t.blockLen=s,t.outputLen=c,t.oHash=r._cloneInto(t.oHash),t.iHash=e._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const xe=(n,t,r)=>new Se(n,t).update(r).digest();xe.create=(n,t)=>new Se(n,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Gt=BigInt(0),Kt=BigInt(1);function qt(n,t=""){if(typeof n!="boolean"){const r=t&&`"${t}"`;throw new Error(r+"expected boolean, got type="+typeof n)}return n}function ft(n,t,r=""){const e=Ct(n),i=n?.length,o=t!==void 0;if(!e||o&&i!==t){const s=r&&`"${r}" `,c=o?` of length ${t}`:"",a=e?`length=${i}`:`type=${typeof n}`;throw new Error(s+"expected Uint8Array"+c+", got "+a)}return n}function Bt(n){const t=n.toString(16);return t.length&1?"0"+t:t}function Be(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?Gt:BigInt("0x"+n)}function Ht(n){return Be(yt(n))}function Ie(n){return mt(n),Be(yt(Uint8Array.from(n).reverse()))}function Qt(n,t){return Rt(n.toString(16).padStart(t*2,"0"))}function Ae(n,t){return Qt(n,t).reverse()}function k(n,t,r){let e;if(typeof t=="string")try{e=Rt(t)}catch(i){throw new Error(n+" must be hex string or Uint8Array, cause: "+i)}else if(Ct(t))e=Uint8Array.from(t);else throw new Error(n+" must be hex string or Uint8Array");return e.length,e}const Ut=n=>typeof n=="bigint"&&Gt<=n;function En(n,t,r){return Ut(n)&&Ut(t)&&Ut(r)&&t<=n&&n<r}function vn(n,t,r,e){if(!En(t,r,e))throw new Error("expected valid "+n+": "+r+" <= n < "+e+", got "+t)}function ze(n){let t;for(t=0;n>Gt;n>>=Kt,t+=1);return t}const vt=n=>(Kt<<BigInt(n))-Kt;function Sn(n,t,r){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const e=u=>new Uint8Array(u),i=u=>Uint8Array.of(u);let o=e(n),s=e(n),c=0;const a=()=>{o.fill(1),s.fill(0),c=0},f=(...u)=>r(s,o,...u),y=(u=e(0))=>{s=f(i(0),u),o=f(),u.length!==0&&(s=f(i(1),u),o=f())},d=()=>{if(c++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const w=[];for(;u<t;){o=f();const E=o.slice();w.push(E),u+=o.length}return ot(...w)};return(u,w)=>{a(),y(u);let E;for(;!(E=w(d()));)y();return a(),E}}function Wt(n,t,r={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function e(i,o,s){const c=n[i];if(s&&c===void 0)return;const a=typeof c;if(a!==o||c===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${a}`)}Object.entries(t).forEach(([i,o])=>e(i,o,!1)),Object.entries(r).forEach(([i,o])=>e(i,o,!0))}function ce(n){const t=new WeakMap;return(r,...e)=>{const i=t.get(r);if(i!==void 0)return i;const o=n(r,...e);return t.set(r,o),o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const K=BigInt(0),P=BigInt(1),dt=BigInt(2),De=BigInt(3),Re=BigInt(4),qe=BigInt(5),xn=BigInt(7),Oe=BigInt(8),Bn=BigInt(9),_e=BigInt(16);function Y(n,t){const r=n%t;return r>=K?r:t+r}function F(n,t,r){let e=n;for(;t-- >K;)e*=e,e%=r;return e}function ae(n,t){if(n===K)throw new Error("invert: expected non-zero number");if(t<=K)throw new Error("invert: expected positive modulus, got "+t);let r=Y(n,t),e=t,i=K,o=P;for(;r!==K;){const c=e/r,a=e%r,f=i-o*c;e=r,r=a,i=o,o=f}if(e!==P)throw new Error("invert: does not exist");return Y(i,t)}function Jt(n,t,r){if(!n.eql(n.sqr(t),r))throw new Error("Cannot find square root")}function Ce(n,t){const r=(n.ORDER+P)/Re,e=n.pow(t,r);return Jt(n,e,t),e}function In(n,t){const r=(n.ORDER-qe)/Oe,e=n.mul(t,dt),i=n.pow(e,r),o=n.mul(t,i),s=n.mul(n.mul(o,dt),i),c=n.mul(o,n.sub(s,n.ONE));return Jt(n,c,t),c}function An(n){const t=St(n),r=He(n),e=r(t,t.neg(t.ONE)),i=r(t,e),o=r(t,t.neg(e)),s=(n+xn)/_e;return(c,a)=>{let f=c.pow(a,s),y=c.mul(f,e);const d=c.mul(f,i),l=c.mul(f,o),u=c.eql(c.sqr(y),a),w=c.eql(c.sqr(d),a);f=c.cmov(f,y,u),y=c.cmov(l,d,w);const E=c.eql(c.sqr(y),a),O=c.cmov(f,y,E);return Jt(c,O,a),O}}function He(n){if(n<De)throw new Error("sqrt is not defined for small field");let t=n-P,r=0;for(;t%dt===K;)t/=dt,r++;let e=dt;const i=St(n);for(;le(i,e)===1;)if(e++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return Ce;let o=i.pow(e,t);const s=(t+P)/dt;return function(a,f){if(a.is0(f))return f;if(le(a,f)!==1)throw new Error("Cannot find square root");let y=r,d=a.mul(a.ONE,o),l=a.pow(f,t),u=a.pow(f,s);for(;!a.eql(l,a.ONE);){if(a.is0(l))return a.ZERO;let w=1,E=a.sqr(l);for(;!a.eql(E,a.ONE);)if(w++,E=a.sqr(E),w===y)throw new Error("Cannot find square root");const O=P<<BigInt(y-w-1),C=a.pow(d,O);y=w,d=a.sqr(C),l=a.mul(l,d),u=a.mul(u,C)}return u}}function zn(n){return n%Re===De?Ce:n%Oe===qe?In:n%_e===Bn?An(n):He(n)}const Dn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Rn(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=Dn.reduce((e,i)=>(e[i]="function",e),t);return Wt(n,r),n}function qn(n,t,r){if(r<K)throw new Error("invalid exponent, negatives unsupported");if(r===K)return n.ONE;if(r===P)return t;let e=n.ONE,i=t;for(;r>K;)r&P&&(e=n.mul(e,i)),i=n.sqr(i),r>>=P;return e}function Te(n,t,r=!1){const e=new Array(t.length).fill(r?n.ZERO:void 0),i=t.reduce((s,c,a)=>n.is0(c)?s:(e[a]=s,n.mul(s,c)),n.ONE),o=n.inv(i);return t.reduceRight((s,c,a)=>n.is0(c)?s:(e[a]=n.mul(s,e[a]),n.mul(s,c)),o),e}function le(n,t){const r=(n.ORDER-P)/dt,e=n.pow(t,r),i=n.eql(e,n.ONE),o=n.eql(e,n.ZERO),s=n.eql(e,n.neg(n.ONE));if(!i&&!o&&!s)throw new Error("invalid Legendre symbol result");return i?1:o?0:-1}function Ne(n,t){t!==void 0&&kt(t);const r=t!==void 0?t:n.toString(2).length,e=Math.ceil(r/8);return{nBitLength:r,nByteLength:e}}function St(n,t,r=!1,e={}){if(n<=K)throw new Error("invalid field: expected ORDER > 0, got "+n);let i,o,s=!1,c;if(typeof t=="object"&&t!=null){if(e.sqrt||r)throw new Error("cannot specify opts in two arguments");const l=t;l.BITS&&(i=l.BITS),l.sqrt&&(o=l.sqrt),typeof l.isLE=="boolean"&&(r=l.isLE),typeof l.modFromBytes=="boolean"&&(s=l.modFromBytes),c=l.allowedLengths}else typeof t=="number"&&(i=t),e.sqrt&&(o=e.sqrt);const{nBitLength:a,nByteLength:f}=Ne(n,i);if(f>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let y;const d=Object.freeze({ORDER:n,isLE:r,BITS:a,BYTES:f,MASK:vt(a),ZERO:K,ONE:P,allowedLengths:c,create:l=>Y(l,n),isValid:l=>{if(typeof l!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof l);return K<=l&&l<n},is0:l=>l===K,isValidNot0:l=>!d.is0(l)&&d.isValid(l),isOdd:l=>(l&P)===P,neg:l=>Y(-l,n),eql:(l,u)=>l===u,sqr:l=>Y(l*l,n),add:(l,u)=>Y(l+u,n),sub:(l,u)=>Y(l-u,n),mul:(l,u)=>Y(l*u,n),pow:(l,u)=>qn(d,l,u),div:(l,u)=>Y(l*ae(u,n),n),sqrN:l=>l*l,addN:(l,u)=>l+u,subN:(l,u)=>l-u,mulN:(l,u)=>l*u,inv:l=>ae(l,n),sqrt:o||(l=>(y||(y=zn(n)),y(d,l))),toBytes:l=>r?Ae(l,f):Qt(l,f),fromBytes:(l,u=!0)=>{if(c){if(!c.includes(l.length)||l.length>f)throw new Error("Field.fromBytes: expected "+c+" bytes, got "+l.length);const E=new Uint8Array(f);E.set(l,r?0:E.length-l.length),l=E}if(l.length!==f)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+l.length);let w=r?Ie(l):Ht(l);if(s&&(w=Y(w,n)),!u&&!d.isValid(w))throw new Error("invalid field element: outside of range 0..ORDER");return w},invertBatch:l=>Te(d,l),cmov:(l,u,w)=>w?u:l});return Object.freeze(d)}function Me(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function Ue(n){const t=Me(n);return t+Math.ceil(t/2)}function On(n,t,r=!1){const e=n.length,i=Me(t),o=Ue(t);if(e<16||e<o||e>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+e);const s=r?Ie(n):Ht(n),c=Y(s,t-P)+P;return r?Ae(c,i):Qt(c,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const wt=BigInt(0),ht=BigInt(1);function Ot(n,t){const r=t.negate();return n?r:t}function $t(n,t){const r=Te(n.Fp,t.map(e=>e.Z));return t.map((e,i)=>n.fromAffine(e.toAffine(r[i])))}function $e(n,t){if(!Number.isSafeInteger(n)||n<=0||n>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+n)}function jt(n,t){$e(n,t);const r=Math.ceil(t/n)+1,e=2**(n-1),i=2**n,o=vt(n),s=BigInt(n);return{windows:r,windowSize:e,mask:o,maxNumber:i,shiftBy:s}}function ue(n,t,r){const{windowSize:e,mask:i,maxNumber:o,shiftBy:s}=r;let c=Number(n&i),a=n>>s;c>e&&(c-=o,a+=ht);const f=t*e,y=f+Math.abs(c)-1,d=c===0,l=c<0,u=t%2!==0;return{nextN:a,offset:y,isZero:d,isNeg:l,isNegF:u,offsetF:f}}function _n(n,t){if(!Array.isArray(n))throw new Error("array expected");n.forEach((r,e)=>{if(!(r instanceof t))throw new Error("invalid point at index "+e)})}function Cn(n,t){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((r,e)=>{if(!t.isValid(r))throw new Error("invalid scalar at index "+e)})}const Lt=new WeakMap,je=new WeakMap;function Vt(n){return je.get(n)||1}function fe(n){if(n!==wt)throw new Error("invalid wNAF")}class Hn{constructor(t,r){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=r}_unsafeLadder(t,r,e=this.ZERO){let i=t;for(;r>wt;)r&ht&&(e=e.add(i)),i=i.double(),r>>=ht;return e}precomputeWindow(t,r){const{windows:e,windowSize:i}=jt(r,this.bits),o=[];let s=t,c=s;for(let a=0;a<e;a++){c=s,o.push(c);for(let f=1;f<i;f++)c=c.add(s),o.push(c);s=c.double()}return o}wNAF(t,r,e){if(!this.Fn.isValid(e))throw new Error("invalid scalar");let i=this.ZERO,o=this.BASE;const s=jt(t,this.bits);for(let c=0;c<s.windows;c++){const{nextN:a,offset:f,isZero:y,isNeg:d,isNegF:l,offsetF:u}=ue(e,c,s);e=a,y?o=o.add(Ot(l,r[u])):i=i.add(Ot(d,r[f]))}return fe(e),{p:i,f:o}}wNAFUnsafe(t,r,e,i=this.ZERO){const o=jt(t,this.bits);for(let s=0;s<o.windows&&e!==wt;s++){const{nextN:c,offset:a,isZero:f,isNeg:y}=ue(e,s,o);if(e=c,!f){const d=r[a];i=i.add(y?d.negate():d)}}return fe(e),i}getPrecomputes(t,r,e){let i=Lt.get(r);return i||(i=this.precomputeWindow(r,t),t!==1&&(typeof e=="function"&&(i=e(i)),Lt.set(r,i))),i}cached(t,r,e){const i=Vt(t);return this.wNAF(i,this.getPrecomputes(i,t,e),r)}unsafe(t,r,e,i){const o=Vt(t);return o===1?this._unsafeLadder(t,r,i):this.wNAFUnsafe(o,this.getPrecomputes(o,t,e),r,i)}createCache(t,r){$e(r,this.bits),je.set(t,r),Lt.delete(t)}hasCache(t){return Vt(t)!==1}}function Tn(n,t,r,e){let i=t,o=n.ZERO,s=n.ZERO;for(;r>wt||e>wt;)r&ht&&(o=o.add(i)),e&ht&&(s=s.add(i)),i=i.double(),r>>=ht,e>>=ht;return{p1:o,p2:s}}function Nn(n,t,r,e){_n(r,n),Cn(e,t);const i=r.length,o=e.length;if(i!==o)throw new Error("arrays of points and scalars must have equal length");const s=n.ZERO,c=ze(BigInt(i));let a=1;c>12?a=c-3:c>4?a=c-2:c>0&&(a=2);const f=vt(a),y=new Array(Number(f)+1).fill(s),d=Math.floor((t.BITS-1)/a)*a;let l=s;for(let u=d;u>=0;u-=a){y.fill(s);for(let E=0;E<o;E++){const O=e[E],C=Number(O>>BigInt(u)&f);y[C]=y[C].add(r[E])}let w=s;for(let E=y.length-1,O=s;E>0;E--)O=O.add(y[E]),w=w.add(O);if(l=l.add(w),u!==0)for(let E=0;E<a;E++)l=l.double()}return l}function de(n,t,r){if(t){if(t.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Rn(t),t}else return St(n,{isLE:r})}function Mn(n,t,r={},e){if(e===void 0&&(e=n==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${n} CURVE object`);for(const a of["p","n","h"]){const f=t[a];if(!(typeof f=="bigint"&&f>wt))throw new Error(`CURVE.${a} must be positive bigint`)}const i=de(t.p,r.Fp,e),o=de(t.n,r.Fn,e),c=["Gx","Gy","a","b"];for(const a of c)if(!i.isValid(t[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:i,Fn:o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const he=(n,t)=>(n+(n>=0?t:-t)/Le)/t;function Un(n,t,r){const[[e,i],[o,s]]=t,c=he(s*n,r),a=he(-i*n,r);let f=n-c*e-a*o,y=-c*i-a*s;const d=f<et,l=y<et;d&&(f=-f),l&&(y=-y);const u=vt(Math.ceil(ze(r)/2))+bt;if(f<et||f>=u||y<et||y>=u)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:d,k1:f,k2neg:l,k2:y}}function Xt(n){if(!["compact","recovered","der"].includes(n))throw new Error('Signature format must be "compact", "recovered", or "der"');return n}function Pt(n,t){const r={};for(let e of Object.keys(t))r[e]=n[e]===void 0?t[e]:n[e];return qt(r.lowS,"lowS"),qt(r.prehash,"prehash"),r.format!==void 0&&Xt(r.format),r}class $n extends Error{constructor(t=""){super(t)}}const tt={Err:$n,_tlv:{encode:(n,t)=>{const{Err:r}=tt;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(t.length&1)throw new r("tlv.encode: unpadded data");const e=t.length/2,i=Bt(e);if(i.length/2&128)throw new r("tlv.encode: long form length too big");const o=e>127?Bt(i.length/2|128):"";return Bt(n)+o+i+t},decode(n,t){const{Err:r}=tt;let e=0;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[e++]!==n)throw new r("tlv.decode: wrong tlv");const i=t[e++],o=!!(i&128);let s=0;if(!o)s=i;else{const a=i&127;if(!a)throw new r("tlv.decode(long): indefinite length not supported");if(a>4)throw new r("tlv.decode(long): byte length is too big");const f=t.subarray(e,e+a);if(f.length!==a)throw new r("tlv.decode: length bytes not complete");if(f[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const y of f)s=s<<8|y;if(e+=a,s<128)throw new r("tlv.decode(long): not minimal encoding")}const c=t.subarray(e,e+s);if(c.length!==s)throw new r("tlv.decode: wrong value length");return{v:c,l:t.subarray(e+s)}}},_int:{encode(n){const{Err:t}=tt;if(n<et)throw new t("integer: negative integers are not allowed");let r=Bt(n);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(n){const{Err:t}=tt;if(n[0]&128)throw new t("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Ht(n)}},toSig(n){const{Err:t,_int:r,_tlv:e}=tt,i=k("signature",n),{v:o,l:s}=e.decode(48,i);if(s.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:a}=e.decode(2,o),{v:f,l:y}=e.decode(2,a);if(y.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(c),s:r.decode(f)}},hexFromSig(n){const{_tlv:t,_int:r}=tt,e=t.encode(2,r.encode(n.r)),i=t.encode(2,r.encode(n.s)),o=e+i;return t.encode(48,o)}},et=BigInt(0),bt=BigInt(1),Le=BigInt(2),It=BigInt(3),jn=BigInt(4);function pt(n,t){const{BYTES:r}=n;let e;if(typeof t=="bigint")e=t;else{let i=k("private key",t);try{e=n.fromBytes(i)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof t}`)}}if(!n.isValidNot0(e))throw new Error("invalid private key: out of range [1..N-1]");return e}function Ln(n,t={}){const r=Mn("weierstrass",n,t),{Fp:e,Fn:i}=r;let o=r.CURVE;const{h:s,n:c}=o;Wt(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:a}=t;if(a&&(!e.is0(o.a)||typeof a.beta!="bigint"||!Array.isArray(a.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const f=Pe(e,i);function y(){if(!e.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(R,p,g){const{x:h,y:b}=p.toAffine(),v=e.toBytes(h);if(qt(g,"isCompressed"),g){y();const B=!e.isOdd(b);return ot(Ve(B),v)}else return ot(Uint8Array.of(4),v,e.toBytes(b))}function l(R){ft(R,void 0,"Point");const{publicKey:p,publicKeyUncompressed:g}=f,h=R.length,b=R[0],v=R.subarray(1);if(h===p&&(b===2||b===3)){const B=e.fromBytes(v);if(!e.isValid(B))throw new Error("bad point: is not on curve, wrong x");const x=E(B);let S;try{S=e.sqrt(x)}catch(U){const H=U instanceof Error?": "+U.message:"";throw new Error("bad point: is not on curve, sqrt error"+H)}y();const A=e.isOdd(S);return(b&1)===1!==A&&(S=e.neg(S)),{x:B,y:S}}else if(h===g&&b===4){const B=e.BYTES,x=e.fromBytes(v.subarray(0,B)),S=e.fromBytes(v.subarray(B,B*2));if(!O(x,S))throw new Error("bad point: is not on curve");return{x,y:S}}else throw new Error(`bad point: got length ${h}, expected compressed=${p} or uncompressed=${g}`)}const u=t.toBytes||d,w=t.fromBytes||l;function E(R){const p=e.sqr(R),g=e.mul(p,R);return e.add(e.add(g,e.mul(R,o.a)),o.b)}function O(R,p){const g=e.sqr(p),h=E(R);return e.eql(g,h)}if(!O(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const C=e.mul(e.pow(o.a,It),jn),nt=e.mul(e.sqr(o.b),BigInt(27));if(e.is0(e.add(C,nt)))throw new Error("bad curve params: a or b");function I(R,p,g=!1){if(!e.isValid(p)||g&&e.is0(p))throw new Error(`bad point coordinate ${R}`);return p}function _(R){if(!(R instanceof D))throw new Error("ProjectivePoint expected")}function T(R){if(!a||!a.basises)throw new Error("no endo");return Un(R,a.basises,i.ORDER)}const L=ce((R,p)=>{const{X:g,Y:h,Z:b}=R;if(e.eql(b,e.ONE))return{x:g,y:h};const v=R.is0();p==null&&(p=v?e.ONE:e.inv(b));const B=e.mul(g,p),x=e.mul(h,p),S=e.mul(b,p);if(v)return{x:e.ZERO,y:e.ZERO};if(!e.eql(S,e.ONE))throw new Error("invZ was invalid");return{x:B,y:x}}),X=ce(R=>{if(R.is0()){if(t.allowInfinityPoint&&!e.is0(R.Y))return;throw new Error("bad point: ZERO")}const{x:p,y:g}=R.toAffine();if(!e.isValid(p)||!e.isValid(g))throw new Error("bad point: x or y not field elements");if(!O(p,g))throw new Error("bad point: equation left != right");if(!R.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function G(R,p,g,h,b){return g=new D(e.mul(g.X,R),g.Y,g.Z),p=Ot(h,p),g=Ot(b,g),p.add(g)}class D{constructor(p,g,h){this.X=I("x",p),this.Y=I("y",g,!0),this.Z=I("z",h),Object.freeze(this)}static CURVE(){return o}static fromAffine(p){const{x:g,y:h}=p||{};if(!p||!e.isValid(g)||!e.isValid(h))throw new Error("invalid affine point");if(p instanceof D)throw new Error("projective point not allowed");return e.is0(g)&&e.is0(h)?D.ZERO:new D(g,h,e.ONE)}static fromBytes(p){const g=D.fromAffine(w(ft(p,void 0,"point")));return g.assertValidity(),g}static fromHex(p){return D.fromBytes(k("pointHex",p))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(p=8,g=!0){return W.createCache(this,p),g||this.multiply(It),this}assertValidity(){X(this)}hasEvenY(){const{y:p}=this.toAffine();if(!e.isOdd)throw new Error("Field doesn't support isOdd");return!e.isOdd(p)}equals(p){_(p);const{X:g,Y:h,Z:b}=this,{X:v,Y:B,Z:x}=p,S=e.eql(e.mul(g,x),e.mul(v,b)),A=e.eql(e.mul(h,x),e.mul(B,b));return S&&A}negate(){return new D(this.X,e.neg(this.Y),this.Z)}double(){const{a:p,b:g}=o,h=e.mul(g,It),{X:b,Y:v,Z:B}=this;let x=e.ZERO,S=e.ZERO,A=e.ZERO,z=e.mul(b,b),U=e.mul(v,v),H=e.mul(B,B),q=e.mul(b,v);return q=e.add(q,q),A=e.mul(b,B),A=e.add(A,A),x=e.mul(p,A),S=e.mul(h,H),S=e.add(x,S),x=e.sub(U,S),S=e.add(U,S),S=e.mul(x,S),x=e.mul(q,x),A=e.mul(h,A),H=e.mul(p,H),q=e.sub(z,H),q=e.mul(p,q),q=e.add(q,A),A=e.add(z,z),z=e.add(A,z),z=e.add(z,H),z=e.mul(z,q),S=e.add(S,z),H=e.mul(v,B),H=e.add(H,H),z=e.mul(H,q),x=e.sub(x,z),A=e.mul(H,U),A=e.add(A,A),A=e.add(A,A),new D(x,S,A)}add(p){_(p);const{X:g,Y:h,Z:b}=this,{X:v,Y:B,Z:x}=p;let S=e.ZERO,A=e.ZERO,z=e.ZERO;const U=o.a,H=e.mul(o.b,It);let q=e.mul(g,v),N=e.mul(h,B),$=e.mul(b,x),Z=e.add(g,h),M=e.add(v,B);Z=e.mul(Z,M),M=e.add(q,N),Z=e.sub(Z,M),M=e.add(g,b);let V=e.add(v,x);return M=e.mul(M,V),V=e.add(q,$),M=e.sub(M,V),V=e.add(h,b),S=e.add(B,x),V=e.mul(V,S),S=e.add(N,$),V=e.sub(V,S),z=e.mul(U,M),S=e.mul(H,$),z=e.add(S,z),S=e.sub(N,z),z=e.add(N,z),A=e.mul(S,z),N=e.add(q,q),N=e.add(N,q),$=e.mul(U,$),M=e.mul(H,M),N=e.add(N,$),$=e.sub(q,$),$=e.mul(U,$),M=e.add(M,$),q=e.mul(N,M),A=e.add(A,q),q=e.mul(V,M),S=e.mul(Z,S),S=e.sub(S,q),q=e.mul(Z,N),z=e.mul(V,z),z=e.add(z,q),new D(S,A,z)}subtract(p){return this.add(p.negate())}is0(){return this.equals(D.ZERO)}multiply(p){const{endo:g}=t;if(!i.isValidNot0(p))throw new Error("invalid scalar: out of range");let h,b;const v=B=>W.cached(this,B,x=>$t(D,x));if(g){const{k1neg:B,k1:x,k2neg:S,k2:A}=T(p),{p:z,f:U}=v(x),{p:H,f:q}=v(A);b=U.add(q),h=G(g.beta,z,H,B,S)}else{const{p:B,f:x}=v(p);h=B,b=x}return $t(D,[h,b])[0]}multiplyUnsafe(p){const{endo:g}=t,h=this;if(!i.isValid(p))throw new Error("invalid scalar: out of range");if(p===et||h.is0())return D.ZERO;if(p===bt)return h;if(W.hasCache(this))return this.multiply(p);if(g){const{k1neg:b,k1:v,k2neg:B,k2:x}=T(p),{p1:S,p2:A}=Tn(D,h,v,x);return G(g.beta,S,A,b,B)}else return W.unsafe(h,p)}multiplyAndAddUnsafe(p,g,h){const b=this.multiplyUnsafe(g).add(p.multiplyUnsafe(h));return b.is0()?void 0:b}toAffine(p){return L(this,p)}isTorsionFree(){const{isTorsionFree:p}=t;return s===bt?!0:p?p(D,this):W.unsafe(this,c).is0()}clearCofactor(){const{clearCofactor:p}=t;return s===bt?this:p?p(D,this):this.multiplyUnsafe(s)}isSmallOrder(){return this.multiplyUnsafe(s).is0()}toBytes(p=!0){return qt(p,"isCompressed"),this.assertValidity(),u(D,this,p)}toHex(p=!0){return yt(this.toBytes(p))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(p=!0){return this.toBytes(p)}_setWindowSize(p){this.precompute(p)}static normalizeZ(p){return $t(D,p)}static msm(p,g){return Nn(D,i,p,g)}static fromPrivateKey(p){return D.BASE.multiply(pt(i,p))}}D.BASE=new D(o.Gx,o.Gy,e.ONE),D.ZERO=new D(e.ZERO,e.ONE,e.ZERO),D.Fp=e,D.Fn=i;const Et=i.BITS,W=new Hn(D,t.endo?Math.ceil(Et/2):Et);return D.BASE.precompute(8),D}function Ve(n){return Uint8Array.of(n?2:3)}function Pe(n,t){return{secretKey:t.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function Vn(n,t={}){const{Fn:r}=n,e=t.randomBytes||Ee,i=Object.assign(Pe(n.Fp,r),{seed:Ue(r.ORDER)});function o(u){try{return!!pt(r,u)}catch{return!1}}function s(u,w){const{publicKey:E,publicKeyUncompressed:O}=i;try{const C=u.length;return w===!0&&C!==E||w===!1&&C!==O?!1:!!n.fromBytes(u)}catch{return!1}}function c(u=e(i.seed)){return On(ft(u,i.seed,"seed"),r.ORDER)}function a(u,w=!0){return n.BASE.multiply(pt(r,u)).toBytes(w)}function f(u){const w=c(u);return{secretKey:w,publicKey:a(w)}}function y(u){if(typeof u=="bigint")return!1;if(u instanceof n)return!0;const{secretKey:w,publicKey:E,publicKeyUncompressed:O}=i;if(r.allowedLengths||w===E)return;const C=k("key",u).length;return C===E||C===O}function d(u,w,E=!0){if(y(u)===!0)throw new Error("first arg must be private key");if(y(w)===!1)throw new Error("second arg must be public key");const O=pt(r,u);return n.fromHex(w).multiply(O).toBytes(E)}return Object.freeze({getPublicKey:a,getSharedSecret:d,keygen:f,Point:n,utils:{isValidSecretKey:o,isValidPublicKey:s,randomSecretKey:c,isValidPrivateKey:o,randomPrivateKey:c,normPrivateKeyToScalar:u=>pt(r,u),precompute(u=8,w=n.BASE){return w.precompute(u,!1)}},lengths:i})}function Pn(n,t,r={}){ye(t),Wt(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const e=r.randomBytes||Ee,i=r.hmac||((g,...h)=>xe(t,g,ot(...h))),{Fp:o,Fn:s}=n,{ORDER:c,BITS:a}=s,{keygen:f,getPublicKey:y,getSharedSecret:d,utils:l,lengths:u}=Vn(n,r),w={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},E="compact";function O(g){const h=c>>bt;return g>h}function C(g,h){if(!s.isValidNot0(h))throw new Error(`invalid signature ${g}: out of range 1..Point.Fn.ORDER`);return h}function nt(g,h){Xt(h);const b=u.signature,v=h==="compact"?b:h==="recovered"?b+1:void 0;return ft(g,v,`${h} signature`)}class I{constructor(h,b,v){this.r=C("r",h),this.s=C("s",b),v!=null&&(this.recovery=v),Object.freeze(this)}static fromBytes(h,b=E){nt(h,b);let v;if(b==="der"){const{r:A,s:z}=tt.toSig(ft(h));return new I(A,z)}b==="recovered"&&(v=h[0],b="compact",h=h.subarray(1));const B=s.BYTES,x=h.subarray(0,B),S=h.subarray(B,B*2);return new I(s.fromBytes(x),s.fromBytes(S),v)}static fromHex(h,b){return this.fromBytes(Rt(h),b)}addRecoveryBit(h){return new I(this.r,this.s,h)}recoverPublicKey(h){const b=o.ORDER,{r:v,s:B,recovery:x}=this;if(x==null||![0,1,2,3].includes(x))throw new Error("recovery id invalid");if(c*Le<b&&x>1)throw new Error("recovery id is ambiguous for h>1 curve");const A=x===2||x===3?v+c:v;if(!o.isValid(A))throw new Error("recovery id 2 or 3 invalid");const z=o.toBytes(A),U=n.fromBytes(ot(Ve((x&1)===0),z)),H=s.inv(A),q=T(k("msgHash",h)),N=s.create(-q*H),$=s.create(B*H),Z=n.BASE.multiplyUnsafe(N).add(U.multiplyUnsafe($));if(Z.is0())throw new Error("point at infinify");return Z.assertValidity(),Z}hasHighS(){return O(this.s)}toBytes(h=E){if(Xt(h),h==="der")return Rt(tt.hexFromSig(this));const b=s.toBytes(this.r),v=s.toBytes(this.s);if(h==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return ot(Uint8Array.of(this.recovery),b,v)}return ot(b,v)}toHex(h){return yt(this.toBytes(h))}assertValidity(){}static fromCompact(h){return I.fromBytes(k("sig",h),"compact")}static fromDER(h){return I.fromBytes(k("sig",h),"der")}normalizeS(){return this.hasHighS()?new I(this.r,s.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return yt(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return yt(this.toBytes("compact"))}}const _=r.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const b=Ht(h),v=h.length*8-a;return v>0?b>>BigInt(v):b},T=r.bits2int_modN||function(h){return s.create(_(h))},L=vt(a);function X(g){return vn("num < 2^"+a,g,et,L),s.toBytes(g)}function G(g,h){return ft(g,void 0,"message"),h?ft(t(g),void 0,"prehashed message"):g}function D(g,h,b){if(["recovered","canonical"].some(N=>N in b))throw new Error("sign() legacy options not supported");const{lowS:v,prehash:B,extraEntropy:x}=Pt(b,w);g=G(g,B);const S=T(g),A=pt(s,h),z=[X(A),X(S)];if(x!=null&&x!==!1){const N=x===!0?e(u.secretKey):x;z.push(k("extraEntropy",N))}const U=ot(...z),H=S;function q(N){const $=_(N);if(!s.isValidNot0($))return;const Z=s.inv($),M=n.BASE.multiply($).toAffine(),V=s.create(M.x);if(V===et)return;const xt=s.create(Z*s.create(H+V*A));if(xt===et)return;let re=(M.x===V?0:2)|Number(M.y&bt),ie=xt;return v&&O(xt)&&(ie=s.neg(xt),re^=1),new I(V,ie,re)}return{seed:U,k2sig:q}}function Et(g,h,b={}){g=k("message",g);const{seed:v,k2sig:B}=D(g,h,b);return Sn(t.outputLen,s.BYTES,i)(v,B)}function W(g){let h;const b=typeof g=="string"||Ct(g),v=!b&&g!==null&&typeof g=="object"&&typeof g.r=="bigint"&&typeof g.s=="bigint";if(!b&&!v)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(v)h=new I(g.r,g.s);else if(b){try{h=I.fromBytes(k("sig",g),"der")}catch(B){if(!(B instanceof tt.Err))throw B}if(!h)try{h=I.fromBytes(k("sig",g),"compact")}catch{return!1}}return h||!1}function R(g,h,b,v={}){const{lowS:B,prehash:x,format:S}=Pt(v,w);if(b=k("publicKey",b),h=G(k("message",h),x),"strict"in v)throw new Error("options.strict was renamed to lowS");const A=S===void 0?W(g):I.fromBytes(k("sig",g),S);if(A===!1)return!1;try{const z=n.fromBytes(b);if(B&&A.hasHighS())return!1;const{r:U,s:H}=A,q=T(h),N=s.inv(H),$=s.create(q*N),Z=s.create(U*N),M=n.BASE.multiplyUnsafe($).add(z.multiplyUnsafe(Z));return M.is0()?!1:s.create(M.x)===U}catch{return!1}}function p(g,h,b={}){const{prehash:v}=Pt(b,w);return h=G(h,v),I.fromBytes(g,"recovered").recoverPublicKey(h).toBytes()}return Object.freeze({keygen:f,getPublicKey:y,getSharedSecret:d,utils:l,lengths:u,Point:n,sign:Et,verify:R,recoverPublicKey:p,Signature:I,hash:t})}function Zn(n){const t={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},r=n.Fp;let e=n.allowedPrivateKeyLengths?Array.from(new Set(n.allowedPrivateKeyLengths.map(s=>Math.ceil(s/2)))):void 0;const i=St(t.n,{BITS:n.nBitLength,allowedLengths:e,modFromBytes:n.wrapPrivateKey}),o={Fp:r,Fn:i,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:t,curveOpts:o}}function kn(n){const{CURVE:t,curveOpts:r}=Zn(n),e={hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:t,curveOpts:r,hash:n.hash,ecdsaOpts:e}}function Kn(n,t){const r=t.Point;return Object.assign({},t,{ProjectivePoint:r,CURVE:Object.assign({},n,Ne(r.Fn.ORDER,r.Fn.BITS))})}function Xn(n){const{CURVE:t,curveOpts:r,hash:e,ecdsaOpts:i}=kn(n),o=Ln(t,r),s=Pn(o,e,i);return Kn(n,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Fn(n,t){const r=e=>Xn({...n,hash:e});return{...r(t),create:r}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const te={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Yn={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},me=BigInt(2);function Gn(n){const t=te.p,r=BigInt(3),e=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),c=BigInt(44),a=BigInt(88),f=n*n*n%t,y=f*f*n%t,d=F(y,r,t)*y%t,l=F(d,r,t)*y%t,u=F(l,me,t)*f%t,w=F(u,i,t)*u%t,E=F(w,o,t)*w%t,O=F(E,c,t)*E%t,C=F(O,a,t)*O%t,nt=F(C,c,t)*E%t,I=F(nt,r,t)*y%t,_=F(I,s,t)*w%t,T=F(_,e,t)*f%t,L=F(T,me,t);if(!Ft.eql(Ft.sqr(L),n))throw new Error("Cannot find square root");return L}const Ft=St(te.p,{sqrt:Gn}),Ze=Fn({...te,Fp:Ft,lowS:!0,endo:Yn},ve),ke=ve,Qn=Ze.ProjectivePoint.BASE,Wn=BigInt("0x50929B74C1A04954B78B4B6035E97A5E078A5A0F28EC96D547BFEE9ACE803AC0"),Jn=BigInt("0x31D3C6863973926E049E637CB1B5F40A36DAC28AF1766968C30C2313F3A38904"),tr=new Ze.ProjectivePoint(Wn,Jn,BigInt(1));function _t(n,t){const r=t||Zt.randomBytes(32);if(r.length!==32)throw new Error("Randomness must be exactly 32 bytes");const e=BigInt(Math.floor(n*1e4)),i=nr(r),o=Qn.multiply(e),s=tr.multiply(i),a=o.add(s).toAffine(),f=ge(a.x,32),y=ge(a.y,32),d=new Uint8Array(64);return d.set(f,0),d.set(y,32),{value:d,randomness:new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}}function Ke(n,t,r){try{const e=_t(t,r);return rr(n.value,e.value)}catch{return!1}}class Xe{threshold;constructor(t){if(t<2)throw new Error("Threshold must be at least 2");this.threshold=t}share(t,r){if(r<this.threshold)throw new Error(`Need at least ${this.threshold} shares`);const i=Math.floor(t*1e6).toString(16).padStart(16,"0");return oe.share(i,r,this.threshold).map((s,c)=>({index:c+1,value:s}))}reconstruct(t){if(t.length<this.threshold)throw new Error(`Insufficient shares: need ${this.threshold}, got ${t.length}`);const r=t.slice(0,this.threshold).map(o=>o.value),e=oe.combine(r);return parseInt(e,16)/1e6}}class er{numNodes;secretSharing;constructor(t=3){if(t<3)throw new Error("MPC requires at least 3 nodes");this.numNodes=t;const r=Math.floor(t/2)+1;this.secretSharing=new Xe(r)}secretShare(t,r){return this.secretSharing.share(t,r)}reconstruct(t){return this.secretSharing.reconstruct(t)}async computeMutualRecognition(t,r){const e=this.reconstruct(t),i=this.reconstruct(r),o=Math.min(e,i);return this.secretShare(o,this.numNodes)}async secureMin(t,r){return this.computeMutualRecognition(t,r)}computeNormalizedAllocation(t,r,e){const i={};for(const[f,y]of Object.entries(t))i[f]=this.reconstruct(y);const o=Object.entries(i).filter(([,f])=>f>0);if(o.length===0)return{};const s=o.reduce((f,[,y])=>f+y,0),c={};let a=r;for(const[f,y]of o){const d=y/s*r,l=e[f]||0,u=Math.min(d,l);c[f]=u,a-=u}if(a>.01){const f=o.filter(([y,d])=>{const l=c[y],u=d/s*r;return l<u});if(f.length>0){const y=f.reduce((d,[,l])=>d+l,0);for(const[d,l]of f){const u=l/y*a;c[d]+=u}}}return c}computeSlotAllocation(t,r,e,i,o,s){const c=new Date().toISOString(),a={};for(const[I,_]of Object.entries(r))a[I]=this.reconstruct(_);let f={};if(o&&s)for(const[I,_]of Object.entries(a))_>0&&o(I,s)&&(f[I]=_);else f={...a};const y=Object.entries(f).filter(([,I])=>I>0);if(y.length===0)return{slotId:t.id,totalQuantity:t.quantity,allocations:{},unusedCapacity:t.quantity,mutualDesires:{},normalizedShares:{},redistributionAmounts:{},timestamp:c};const d={};for(const[I]of y){const _=e[I]||0,T=i[I]||0,L=Math.min(_,T);L>0&&(d[I]={recipientDesire:_,providerDesire:T,mutual:L})}const l=y.filter(([I])=>(d[I]?.mutual||0)>0);if(l.length===0)return{slotId:t.id,totalQuantity:t.quantity,allocations:{},unusedCapacity:t.quantity,mutualDesires:d,normalizedShares:{},redistributionAmounts:{},timestamp:c};const u=l.reduce((I,[,_])=>I+_,0),w={};for(const[I,_]of l)w[I]=_/u;const E={};let O=0;for(const[I,_]of Object.entries(w)){const T=t.quantity*_,L=d[I]?.mutual||0,X=Math.min(T,L);X>0&&(E[I]=X,O+=X)}let C=t.quantity-O;const nt={};if(C>.01){const I=l.filter(([_,T])=>{const L=E[_]||0,X=T/u*t.quantity,G=d[_]?.mutual||0;return L<Math.min(X,G)});if(I.length>0){const _=I.reduce((T,[,L])=>T+L,0);for(const[T,L]of I){const X=L/_,G=C*X,D=E[T]||0,W=(d[T]?.mutual||0)-D,R=Math.min(G,W);R>0&&(nt[T]=R,E[T]=D+R,O+=R)}C=t.quantity-O}}return{slotId:t.id,totalQuantity:t.quantity,allocations:E,unusedCapacity:C,mutualDesires:d,normalizedShares:w,redistributionAmounts:nt,timestamp:c}}computeMultiSlotAllocation(t,r,e,i,o,s){const c=[];for(const a of t){const f={},y={};for(const l of Object.keys(r))f[l]=e[l]?.[a.id]||0,y[l]=i[l]?.[a.id]||0;const d=this.computeSlotAllocation(a,r,f,y,o,s);c.push(d)}return c}}function nr(n){let t=BigInt(0);for(const r of n)t=t<<BigInt(8)|BigInt(r);return t}function ge(n,t){const r=new Uint8Array(t);let e=n;for(let i=t-1;i>=0;i--)r[i]=Number(e&BigInt(255)),e=e>>BigInt(8);return r}function rr(n,t){if(n.length!==t.length)return!1;let r=0;for(let e=0;e<n.length;e++)r|=n[e]^t[e];return r===0}class ir{computeAllocationInEnclave(t,r,e){for(const d of t)if(!Ke(d.commitment,d.value,d.randomness))throw new Error(`Invalid commitment from ${d.from} to ${d.to}`);const i={},o=new Set;for(const d of t)o.add(d.from),o.add(d.to);for(const d of t){const l=t.find(u=>u.from===d.to&&u.to===d.from);if(l){const u=Math.min(d.value,l.value);i[d.to]=(i[d.to]||0)+u}}const s=Object.values(i).reduce((d,l)=>d+l,0),c=[];if(s>0)for(const[d,l]of Object.entries(i)){const u=l/s*r,w=e[d]||0,E=Math.min(u,w);E>0&&c.push({recipientDid:d,quantityAllocated:E})}const a=Buffer.from(`RDX_Allocation_Enclave_v1:${c.length}:${r}`),f=ke(a),y=new Uint8Array(f.buffer,f.byteOffset,f.byteLength);return{allocations:c,attestation:y}}}const j=m.z.string().regex(/^did:[a-z0-9]+:.+/,"Invalid DID format").describe("Decentralized Identifier"),Tt=m.z.number().min(0,"Percentage cannot be negative").max(100,"Percentage cannot exceed 100").describe("Recognition percentage (0-100)"),st=m.z.string().regex(/^cap-[a-f0-9]{16}$/,"Invalid capacity ID format").describe("Capacity identifier"),Fe=m.z.string().regex(/^[a-f0-9]+$/i,"Must be a hex string"),Ye=m.z.instanceof(Uint8Array).refine(n=>n.length===32,"Must be exactly 32 bytes"),Ge=m.z.instanceof(Uint8Array).refine(n=>n.length===64,"Must be exactly 64 bytes"),Qe=m.z.object({value:Ge.describe("EC point (x,y coordinates)"),randomness:Ye.describe("Random blinding factor")}).strict().describe("Pedersen commitment"),ee=m.z.object({index:m.z.number().int().positive().describe("Share index (1-based)"),value:Fe.describe("Share value as hex string")}).strict().describe("Shamir secret share"),or=m.z.object({shares:m.z.array(ee).min(1)}).strict().describe("MPC share bundle"),We=m.z.object({did:j,name:m.z.string().min(1,"Name cannot be empty"),publicKey:m.z.string().optional()}).strict().describe("System participant"),Je=m.z.object({percentage:Tt}).strict().describe("Recognition value"),tn=m.z.object({participantA:j,participantB:j,value:Tt.describe("min(R[A][B], R[B][A])")}).strict().describe("Mutual recognition between two participants"),sr=m.z.record(m.z.string(),m.z.any()).describe("Filters for recipient eligibility"),ct=m.z.string().regex(/^slot-[a-f0-9]{16}$/,"Invalid slot ID format").describe("Slot identifier"),en=m.z.object({id:ct,quantity:m.z.number().nonnegative("Slot quantity cannot be negative"),metadata:m.z.record(m.z.string(),m.z.any()).optional(),startDate:m.z.string().datetime().optional(),endDate:m.z.string().datetime().optional(),recurrence:m.z.string().optional()}).strict().describe("Availability slot within a capacity"),ne=m.z.object({id:st,providerDid:j,capacityType:m.z.string().min(1,"Capacity type cannot be empty"),totalQuantity:m.z.number().positive("Quantity must be positive"),unit:m.z.string().min(1,"Unit cannot be empty"),filters:sr.default({}),availabilitySlots:m.z.array(en).default([]).describe("Time or resource slots for allocation")}).strict().describe("Declared capacity"),nn=m.z.object({recipientDid:j,capacityId:st,quantityDesired:m.z.number().positive("Desired quantity must be positive"),slotId:ct.optional().describe("Optional slot-specific desire")}).strict().describe("Recipient desire for capacity"),cr=m.z.object({recipientDid:j,capacityId:st,slotId:ct.optional(),recipientDesire:m.z.number().nonnegative(),providerDesire:m.z.number().nonnegative(),mutual:m.z.number().nonnegative().describe("min(provider, recipient)")}).strict().describe("Mutual desire between provider and recipient"),ar=m.z.object({providerDid:j,recipientDid:j,capacityId:st,slotId:ct.optional(),quantityOffered:m.z.number().nonnegative("Offered quantity cannot be negative")}).strict().describe("Provider's desire to allocate to specific recipient"),rn=m.z.object({capacityId:st,slotId:ct.optional(),recipientDid:j,quantityAllocated:m.z.number().nonnegative("Allocated quantity cannot be negative"),proof:m.z.instanceof(Uint8Array).optional(),confirmed:m.z.boolean().default(!1)}).strict().describe("Computed allocation"),on=m.z.record(j,m.z.number().nonnegative()).describe("Map of recipient DIDs to allocated quantities"),lr=m.z.object({slotId:ct,totalQuantity:m.z.number().nonnegative(),allocations:on,unusedCapacity:m.z.number().nonnegative(),mutualDesires:m.z.record(j,m.z.object({recipientDesire:m.z.number().nonnegative(),providerDesire:m.z.number().nonnegative(),mutual:m.z.number().nonnegative()})),normalizedShares:m.z.record(j,m.z.number().nonnegative()),redistributionAmounts:m.z.record(j,m.z.number().nonnegative()),timestamp:m.z.string().datetime()}).strict().describe("Complete slot allocation result with full transparency"),ur=m.z.object({allocations:m.z.array(m.z.object({recipientDid:j,quantityAllocated:m.z.number().nonnegative(),slotId:ct.optional()})),attestation:m.z.instanceof(Uint8Array).describe("TEE attestation")}).strict().describe("TEE allocation output"),sn=m.z.object({mpcNodes:m.z.number().int().min(3,"MPC requires at least 3 nodes").default(3),threshold:m.z.number().int().min(2,"Threshold must be at least 2").optional(),logLevel:m.z.enum(["DEBUG","INFO","WARN","ERROR"]).default("INFO")}).strict().refine(n=>(n.threshold||Math.floor(n.mpcNodes/2)+1)<=n.mpcNodes,{message:"Threshold cannot exceed number of MPC nodes"}).describe("RDX system configuration"),cn=m.z.enum(["AND","OR","XOR","NOT"]),At=m.z.instanceof(Uint8Array).refine(n=>n.length===16,"Wire label must be 16 bytes (128 bits)"),fr=m.z.object({type:cn,inputs:m.z.array(m.z.number().int().nonnegative()).min(1).max(2),output:m.z.number().int().nonnegative()}).strict(),an=m.z.object({encryptedTable:m.z.array(m.z.instanceof(Uint8Array))}).strict(),dr=m.z.object({gates:m.z.array(an),inputWireLabels:m.z.record(m.z.string(),m.z.tuple([At,At])),outputWireLabels:m.z.record(m.z.string(),At)}).strict(),hr=m.z.discriminatedUnion("operation",[m.z.object({operation:m.z.literal("addParticipant"),did:j,name:m.z.string(),publicKey:m.z.string().optional()}),m.z.object({operation:m.z.literal("getParticipant"),did:j}),m.z.object({operation:m.z.literal("addCapacity"),capacity:ne}),m.z.object({operation:m.z.literal("addDesire"),recipientDid:j,capacityId:st,quantityDesired:m.z.number().positive()})]);function at(n,t){const r=n.safeParse(t);if(!r.success){const e=r.error.errors.map(i=>`${i.path.join(".")}: ${i.message}`);throw new Error(`Validation failed:
${e.join(`
`)}`)}return r.data}function mr(n,t){return n.safeParse(t).success}function gr(n,t){const r=n.safeParse(t);return r.success?[]:r.error.errors.map(e=>`${e.path.join(".")}: ${e.message}`)}const lt={DID:j,Percentage:Tt,CapacityID:st,HexString:Fe,Bytes32:Ye,Bytes64:Ge,Commitment:Qe,Share:ee,MPCShare:or,Participant:We,RecognitionValue:Je,MutualRecognition:tn,SlotID:ct,AvailabilitySlot:en,Capacity:ne,Desire:nn,MutualDesire:cr,ProviderDesire:ar,Allocation:rn,AllocationResult:on,SlotAllocationResult:lr,AllocationOutput:ur,RDXConfig:sn,GateType:cn,WireLabel:At,Gate:fr,GarbledGate:an,GarbledCircuit:dr,StorageOperation:hr};class Nt extends Error{constructor(t){super(t),this.name="RDXException"}}class ut extends Nt{constructor(t){super(t),this.name="ValidationError"}}class pr extends Nt{constructor(t){super(t),this.name="CryptographicError"}}class yr extends Nt{constructor(t){super(t),this.name="AllocationError"}}function br(n,t,r){return at(lt.Participant,{did:n,name:t,publicKey:r})}function wr(n){return at(lt.RecognitionValue,{percentage:n})}function Er(n,t,r){return at(lt.MutualRecognition,{participantA:n,participantB:t,value:r})}function vr(n,t,r,e,i,o,s){return at(lt.Capacity,{id:n,providerDid:t,capacityType:r,totalQuantity:e,unit:i,filters:o??{},availabilitySlots:s??[]})}function Sr(n,t,r,e){return at(lt.Desire,{recipientDid:n,capacityId:t,quantityDesired:r,slotId:e})}function xr(n,t,r,e,i,o){return at(lt.Allocation,{capacityId:n,slotId:e,recipientDid:t,quantityAllocated:r,proof:i,confirmed:o??!1})}function Br(n,t,r){return at(lt.RDXConfig,{mpcNodes:n??3,threshold:t,logLevel:r??"INFO"})}class Ir{metrics=new Map;startOperation(t){const r=performance.now();return()=>{const i=performance.now()-r,o=this.metrics.get(t)||{count:0,totalTime:0},s=o.count+1,c=o.totalTime+i;this.metrics.set(t,{count:s,totalTime:c,avgTime:c/s})}}getMetrics(t){return t?this.metrics.get(t)||null:Object.fromEntries(this.metrics)}report(){const t=["Performance Metrics Report:","=".repeat(60)];for(const[r,e]of this.metrics.entries())t.push(`${r}:`),t.push(`  Count: ${e.count}`),t.push(`  Total Time: ${e.totalTime.toFixed(2)}ms`),t.push(`  Avg Time: ${e.avgTime.toFixed(2)}ms`),t.push("");return t.join(`
`)}reset(){this.metrics.clear()}}class ln{value;cleared=!1;constructor(t){this.value=t}get(){if(this.cleared)throw new Error("Secure memory has been cleared");if(this.value===null)throw new Error("Value is null");return this.value}clear(){this.value&&typeof this.value=="object"&&this.value instanceof Uint8Array&&this.value.fill(0),this.value=null,this.cleared=!0}isCleared(){return this.cleared}}class Ar{static createWithRandomness(t){const r=Zt.randomBytes(32);return{commitment:_t(t,r),randomness:r}}static createSecure(t){const r=new ln(Zt.randomBytes(32));return{commitment:_t(t,r.get()),getRandomness:()=>r.get(),clearRandomness:()=>r.clear()}}}let pe;class zr{constructor(t={}){this.options=t}holster;user;isInitialized=!1;async initialize(t){if(this.isInitialized)return;const r=await Promise.resolve().then(()=>require("./index-BC3xq5Oq.cjs")).then(e=>e.index);pe=r.default||r,this.holster=pe(this.options),this.user=this.holster.user(t),this.isInitialized=!0,console.log(`[HOLSTER] Initialized storage for user: ${t.substring(0,20)}...`)}ensureInitialized(){if(!this.isInitialized)throw new Error("Holster storage not initialized. Call initialize() first.")}addParticipant(t,r,e=""){this.ensureInitialized();const i={did:t,name:r,publicKey:e,createdAt:Date.now()};this.user.get("participants").get(t).put(i,o=>{if(o)throw new ut(`Failed to add participant: ${o}`);console.log(`[HOLSTER] Added participant: ${r} (${t.substring(0,20)}...)`)})}getParticipant(t){return this.ensureInitialized(),new Promise(r=>{this.user.get("participants").get(t).once(e=>{if(!e){r(null);return}r({did:e.did,name:e.name,publicKey:e.publicKey})})})}listParticipants(){return this.ensureInitialized(),new Promise(t=>{const r=[];this.user.get("participants").map().once((e,i)=>{e&&i!=="_"&&r.push({did:e.did,name:e.name,publicKey:e.publicKey}),t(r)})})}addCapacity(t){this.ensureInitialized();const r={id:t.id,providerDid:t.providerDid,capacityType:t.capacityType,totalQuantity:t.totalQuantity,unit:t.unit,filters:t.filters,createdAt:Date.now()};this.user.get("capacities").get(t.id).put(r,e=>{if(e)throw new ut(`Failed to add capacity: ${e}`);console.log(`[HOLSTER] Added capacity: ${t.id}`)}),t.availabilitySlots&&t.availabilitySlots.length>0&&t.availabilitySlots.forEach(e=>{this.addSlot(e,t.id)})}getCapacity(t){return this.ensureInitialized(),new Promise(async r=>{this.user.get("capacities").get(t).once(async e=>{if(!e){r(null);return}const i=await this.getSlots(t);r({id:e.id,providerDid:e.providerDid,capacityType:e.capacityType,totalQuantity:e.totalQuantity,unit:e.unit,filters:e.filters||{},availabilitySlots:i})})})}listCapacities(t){return this.ensureInitialized(),new Promise(r=>{const e=[];this.user.get("capacities").map().once(async(i,o)=>{if(!(!i||o==="_")){if(!t||i.providerDid===t){const s=await this.getSlots(i.id);e.push({id:i.id,providerDid:i.providerDid,capacityType:i.capacityType,totalQuantity:i.totalQuantity,unit:i.unit,filters:i.filters||{},availabilitySlots:s})}r(e)}})})}addSlot(t,r){this.ensureInitialized();const e={id:t.id,capacityId:r,quantity:t.quantity,metadata:t.metadata,startDate:t.startDate,endDate:t.endDate,recurrence:t.recurrence,createdAt:Date.now()};this.user.get("slots").get(r).get(t.id).put(e,i=>{if(i)throw new ut(`Failed to add slot: ${i}`);console.log(`[HOLSTER] Added slot: ${t.id} to capacity ${r}`)})}getSlots(t){return this.ensureInitialized(),new Promise(r=>{const e=[];this.user.get("slots").get(t).map().once((i,o)=>{!i||o==="_"||(e.push({id:i.id,quantity:i.quantity,metadata:i.metadata,startDate:i.startDate,endDate:i.endDate,recurrence:i.recurrence}),r(e))})})}addDesire(t,r,e,i){this.ensureInitialized();const o=`${t}_${r}_${i||"none"}`,s={recipientDid:t,capacityId:r,slotId:i||null,quantityDesired:e,createdAt:Date.now()};this.user.get("desires").get(o).put(s,c=>{if(c)throw new ut(`Failed to add desire: ${c}`);console.log(`[HOLSTER] Added desire: ${o}`)})}getDesires(t,r){return this.ensureInitialized(),new Promise(e=>{const i=[];this.user.get("desires").map().once((o,s)=>{!o||s==="_"||(o.capacityId===t&&(r?o.slotId===r:o.slotId===null)&&i.push({recipientDid:o.recipientDid,quantity:o.quantityDesired}),e(i))})})}addProviderDesire(t){this.ensureInitialized();const r=`${t.recipientDid}_${t.capacityId}_${t.slotId||"none"}`,e={providerDid:t.providerDid,recipientDid:t.recipientDid,capacityId:t.capacityId,slotId:t.slotId||null,quantityOffered:t.quantityOffered,createdAt:Date.now()};this.user.get("providerDesires").get(r).put(e,i=>{if(i)throw new ut(`Failed to add provider desire: ${i}`);console.log(`[HOLSTER] Added provider desire: ${r}`)})}getProviderDesires(t,r){return this.ensureInitialized(),new Promise(e=>{const i=[];this.user.get("providerDesires").map().once((o,s)=>{!o||s==="_"||(o.capacityId===t&&(r?o.slotId===r:o.slotId===null)&&i.push({recipientDid:o.recipientDid,quantity:o.quantityOffered}),e(i))})})}addCommitment(t,r,e,i){this.ensureInitialized();const o={fromDid:t,toDid:r,commitment:Array.from(e),randomness:Array.from(i),createdAt:Date.now()};this.user.get("commitments").get(r).put(o,s=>{if(s)throw new ut(`Failed to add commitment: ${s}`);console.log(`[HOLSTER] Added commitment to ${r.substring(0,20)}...`)})}getCommitment(t,r){return this.ensureInitialized(),new Promise(e=>{this.user.get("commitments").get(r).once(i=>{if(!i||i.fromDid!==t){e(null);return}e({commitment:new Uint8Array(i.commitment),randomness:new Uint8Array(i.randomness)})})})}addAllocation(t){this.ensureInitialized();const r=`${t.capacityId}_${t.slotId||"none"}_${t.recipientDid}`,e={capacityId:t.capacityId,slotId:t.slotId||null,recipientDid:t.recipientDid,quantityAllocated:t.quantityAllocated,proof:t.proof?Array.from(t.proof):null,confirmed:t.confirmed,createdAt:Date.now()};this.user.get("allocations").get(r).put(e,i=>{i?console.error("[HOLSTER] Failed to add allocation:",i):console.log(`[HOLSTER] Added allocation: ${r}`)})}getAllocations(t,r){return this.ensureInitialized(),new Promise(e=>{const i=[];this.user.get("allocations").map().once((o,s)=>{!o||s==="_"||(o.capacityId===t&&(!r||o.slotId===r)&&i.push({capacityId:o.capacityId,slotId:o.slotId,recipientDid:o.recipientDid,quantityAllocated:o.quantityAllocated,proof:o.proof?new Uint8Array(o.proof):void 0,confirmed:o.confirmed}),e(i))})})}transaction(t){return t()}close(){console.log("[HOLSTER] Closing storage connection"),this.isInitialized=!1}}exports.AllocationError=yr;exports.AllocationSchema=rn;exports.CapacityIDSchema=st;exports.CapacitySchema=ne;exports.CommitmentHelper=Ar;exports.CommitmentSchema=Qe;exports.CryptographicError=pr;exports.DIDSchema=j;exports.DesireSchema=nn;exports.HolsterStorage=zr;exports.MPCProtocol=er;exports.MetricsCollector=Ir;exports.MutualRecognitionSchema=tn;exports.ParticipantSchema=We;exports.PercentageSchema=Tt;exports.RDXConfigSchema=sn;exports.RDXException=Nt;exports.RecognitionValueSchema=Je;exports.Schemas=lt;exports.SecretSharing=Xe;exports.SecureMemory=ln;exports.ShareSchema=ee;exports.TEESimulator=ir;exports.ValidationError=ut;exports.commit=_t;exports.createAllocation=xr;exports.createCapacity=vr;exports.createDesire=Sr;exports.createMutualRecognition=Er;exports.createParticipant=br;exports.createRDXConfig=Br;exports.createRecognitionValue=wr;exports.getValidationErrors=gr;exports.parse=at;exports.sha256=ke;exports.validate=mr;exports.verifyCommitment=Ke;
//# sourceMappingURL=holster-storage-C9HD0S4m.cjs.map
